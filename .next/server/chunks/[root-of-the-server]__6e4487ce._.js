module.exports = {

"[project]/.next-internal/server/app/api/telegram/webhook/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/http2 [external] (http2, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[project]/src/lib/sheets/service.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/googleapis/build/src/index.js [app-route] (ecmascript)");
;
class GoogleSheetsService {
    sheets;
    auth;
    config;
    constructor(config){
        this.config = config;
        this.initializeAuth();
    }
    async initializeAuth() {
        try {
            this.auth = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].auth.GoogleAuth({
                credentials: this.config.credentials,
                scopes: [
                    'https://www.googleapis.com/auth/spreadsheets'
                ]
            });
            this.sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
                version: 'v4',
                auth: this.auth
            });
        } catch (error) {
            console.error('Erro ao inicializar autentica√ß√£o Google Sheets:', error);
            throw error;
        }
    }
    async addBetData(betData) {
        try {
            console.log('Dados recebidos para salvar:', betData);
            const values = this.formatBetDataForSheets(betData);
            console.log('Valores formatados:', values);
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: this.config.range,
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values: [
                        values
                    ]
                }
            };
            console.log('Enviando para Google Sheets:', request);
            const response = await this.sheets.spreadsheets.values.append(request);
            console.log('Resposta do Google Sheets:', response.status, response.statusText);
            if (response.status === 200) {
                console.log('‚úÖ Dados adicionados com sucesso ao Google Sheets');
                return true;
            }
            console.error('‚ùå Falha ao adicionar dados - Status:', response.status);
            return false;
        } catch (error) {
            console.error('‚ùå Erro ao adicionar dados ao Google Sheets:', error);
            if (error instanceof Error && error.response) {
                console.error('Detalhes do erro:', error.response.data);
            }
            return false;
        }
    }
    async addMultipleBetData(betDataArray) {
        if (betDataArray.length === 0) return 0;
        try {
            const values = betDataArray.map((bet)=>this.formatBetDataForSheets(bet));
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: this.config.range,
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values
                }
            };
            const response = await this.sheets.spreadsheets.values.append(request);
            if (response.status === 200) {
                console.log(`${betDataArray.length} registros adicionados com sucesso`);
                return betDataArray.length;
            }
            return 0;
        } catch (error) {
            console.error('Erro ao adicionar m√∫ltiplos dados:', error);
            return 0;
        }
    }
    formatBetDataForSheets(betData) {
        // Formata√ß√£o corrigida para a estrutura real da planilha
        return [
            betData.data instanceof Date ? betData.data.toLocaleString('pt-BR') : new Date(betData.data).toLocaleString('pt-BR'),
            betData.jogo,
            betData.placar || '0-0',
            betData.linha_da_aposta,
            betData.mercado,
            typeof betData.odd_tipster === 'number' ? betData.odd_tipster.toString() : betData.odd_tipster,
            betData.pegou === true ? 'SIM' : betData.pegou === false ? 'N√ÉO' : 'PENDENTE',
            betData.odd_real ? betData.odd_real.toString() : '',
            '',
            betData.resultado_aposta || 'Pendente'
        ];
    }
    async createHeaderRow() {
        try {
            const headers = [
                'Data',
                'Jogo',
                'Placar',
                'Linha_da_Aposta',
                'Mercado',
                'Odd_Tipster',
                'Pegou',
                'Odd_Real',
                'Resultado_Jogo',
                'Resultado_Aposta' // J
            ];
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: 'A1:J1',
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values: [
                        headers
                    ]
                }
            };
            const response = await this.sheets.spreadsheets.values.update(request);
            console.log('Cabe√ßalho criado:', response.status === 200 ? 'Sucesso' : 'Falha');
            return response.status === 200;
        } catch (error) {
            console.error('Erro ao criar cabe√ßalho:', error);
            return false;
        }
    }
    async getSheetData(range) {
        try {
            const response = await this.sheets.spreadsheets.values.get({
                spreadsheetId: this.config.spreadsheetId,
                range: range || this.config.range
            });
            return response.data.values || [];
        } catch (error) {
            console.error('Erro ao buscar dados da planilha:', error);
            return [];
        }
    }
    // M√©todo para testar a conex√£o
    async testConnection() {
        try {
            const response = await this.sheets.spreadsheets.get({
                spreadsheetId: this.config.spreadsheetId
            });
            console.log('‚úÖ Conex√£o com Google Sheets OK:', response.data.properties.title);
            return true;
        } catch (error) {
            console.error('‚ùå Erro na conex√£o com Google Sheets:', error);
            return false;
        }
    }
}
const __TURBOPACK__default__export__ = GoogleSheetsService;
}),
"[externals]/websocket [external] (websocket, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("websocket", () => require("websocket"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/constants [external] (constants, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("constants", () => require("constants"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[project]/src/lib/gemini/parser.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GeminiParser": ()=>GeminiParser
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
// Carregar vari√°veis de ambiente
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].config({
    path: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), '.env.local')
});
class GeminiParser {
    static API_KEY = process.env.GEMINI_API_KEY;
    static API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';
    static async parseBetMessage(message, chatId, userId, username) {
        if (!this.API_KEY) {
            console.error('‚ùå GEMINI_API_KEY n√£o configurada no .env.local');
            console.error('Verifique se a vari√°vel GEMINI_API_KEY est√° presente no arquivo .env.local');
            return null;
        }
        console.log('‚úÖ GEMINI_API_KEY carregada com sucesso');
        try {
            const prompt = `
Analise esta mensagem de aposta do Telegram e extraia as informa√ß√µes em formato JSON v√°lido.

Mensagem: "${message}"

Voc√™ deve extrair:
- jogo: Os times que est√£o jogando (formato: "Time A vs Time B")
- mercado: Tipo de aposta ("Goal Line", "Asian Handicap", "Resultado Final", "Over/Under", etc.)
- linha_da_aposta: A linha espec√≠fica da aposta (ex: "GL +0.5", "AH -1.0", "Over 2.5", etc.)
- odd_tipster: A odd fornecida pelo tipster (apenas o n√∫mero, ex: "1.85")
- placar: O placar atual do jogo se mencionado na mensagem (ex: "2x1", "1-0", "3x2"). Se n√£o houver placar ou o jogo n√£o tiver come√ßado, use "0-0"

Exemplos de formato para linha_da_aposta:
- Goal Line: "GL +0.5", "GL -1.0", "GL 0.0"
- Asian Handicap: "AH +1.5", "AH -0.5", "AH 0.0"
- Over/Under: "Over 2.5", "Under 1.5"
- Resultado: "1", "X", "2"

Exemplos de placar:
- Se a mensagem menciona "Flamengo 2x1 Palmeiras" ‚Üí placar: "2x1"
- Se a mensagem menciona "jogo come√ßou 1-0" ‚Üí placar: "1x0"
- Se n√£o menciona placar ou diz "jogo √†s 20h" ‚Üí placar: "0-0"

Retorne APENAS um JSON v√°lido no formato:
{
  "jogo": "Time A vs Time B",
  "mercado": "Goal Line",
  "linha_da_aposta": "GL +0.5",
  "odd_tipster": "1.85",
  "placar": "2x1" ou "0-0"
}

Se n√£o conseguir extrair alguma informa√ß√£o, use null para esse campo (exceto placar que deve ser "0-0").`;
            const response = await fetch(`${this.API_URL}?key=${this.API_KEY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [
                        {
                            parts: [
                                {
                                    text: prompt
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: 0.1,
                        maxOutputTokens: 300
                    }
                })
            });
            if (!response.ok) {
                const errorText = await response.text();
                console.error('Erro na API do Gemini:', response.status, response.statusText, errorText);
                return null;
            }
            const result = await response.json();
            if (!result.candidates || result.candidates.length === 0) {
                console.error('Nenhuma resposta do Gemini');
                return null;
            }
            const text = result.candidates[0].content.parts[0].text;
            console.log('Resposta do Gemini:', text);
            // Extrair JSON da resposta
            const jsonMatch = text.match(/\{[\s\S]*?\}/);
            if (!jsonMatch) {
                console.error('JSON n√£o encontrado na resposta do Gemini');
                return null;
            }
            let parsedData;
            try {
                parsedData = JSON.parse(jsonMatch[0]);
            } catch (parseError) {
                console.error('Erro ao fazer parse do JSON:', parseError);
                return null;
            }
            // Validar dados essenciais
            if (!parsedData.jogo || !parsedData.odd_tipster) {
                console.error('Dados essenciais n√£o encontrados');
                return null;
            }
            return {
                id: `${chatId}_${userId}_${Date.now()}`,
                chatId,
                userId,
                username,
                message,
                data: new Date(),
                jogo: parsedData.jogo,
                mercado: parsedData.mercado || 'Pendente',
                linha_da_aposta: parsedData.linha_da_aposta || 'N√£o identificado',
                odd_tipster: parseFloat(parsedData.odd_tipster),
                placar: parsedData.placar || '0-0',
                pegou: null,
                odd_real: null,
                resultado_aposta: 'Pendente'
            };
        } catch (error) {
            console.error('Erro ao processar mensagem com Gemini:', error);
            return null;
        }
    }
    static async parseImageMessage(imageUrl, caption, chatId, userId, username) {
        if (!this.API_KEY) {
            console.error('GEMINI_API_KEY n√£o configurada');
            return null;
        }
        try {
            console.log('üñºÔ∏è Analisando imagem com Gemini:', imageUrl);
            // Baixar a imagem e converter para base64
            const imageResponse = await fetch(imageUrl);
            if (!imageResponse.ok) {
                console.error('Erro ao baixar imagem:', imageResponse.status);
                return null;
            }
            const imageBuffer = await imageResponse.arrayBuffer();
            const base64Image = Buffer.from(imageBuffer).toString('base64');
            const prompt = `
Analise esta imagem de aposta esportiva e extraia as informa√ß√µes em formato JSON v√°lido.

${caption ? `Legenda da imagem: "${caption}"` : ''}

Voc√™ deve extrair:
- jogo: Os times que est√£o jogando (formato: "Time A vs Time B")
- mercado: Tipo de aposta ("Goal Line", "Asian Handicap", "Resultado Final", "Over/Under", etc.)
- linha_da_aposta: A linha espec√≠fica da aposta (ex: "GL +0.5", "AH -1.0", "Over 2.5", etc.)
- odd_tipster: A odd fornecida pelo tipster (apenas o n√∫mero, ex: "1.85")
- placar: O placar atual do jogo se vis√≠vel na imagem (ex: "2x1", "1-0", "3x2"). Se n√£o houver placar ou o jogo n√£o tiver come√ßado, use "0-0"

Exemplos de formato para linha_da_aposta:
- Goal Line: "GL +0.5", "GL -1.0", "GL 0.0"
- Asian Handicap: "AH +1.5", "AH -0.5", "AH 0.0"
- Over/Under: "Over 2.5", "Under 1.5"
- Resultado: "1", "X", "2"

Retorne APENAS um JSON v√°lido no formato:
{
  "jogo": "Time A vs Time B",
  "mercado": "Goal Line",
  "linha_da_aposta": "GL +0.5",
  "odd_tipster": "1.85",
  "placar": "2x1" ou "0-0"
}

Se n√£o conseguir extrair alguma informa√ß√£o, use null para esse campo (exceto placar que deve ser "0-0").`;
            const response = await fetch(`${this.API_URL}?key=${this.API_KEY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [
                        {
                            parts: [
                                {
                                    text: prompt
                                },
                                {
                                    inline_data: {
                                        mime_type: 'image/jpeg',
                                        data: base64Image
                                    }
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: 0.1,
                        maxOutputTokens: 300
                    }
                })
            });
            if (!response.ok) {
                const errorText = await response.text();
                console.error('Erro na API do Gemini:', response.status, response.statusText, errorText);
                return null;
            }
            const result = await response.json();
            if (!result.candidates || result.candidates.length === 0) {
                console.error('Nenhuma resposta do Gemini para imagem');
                return null;
            }
            const text = result.candidates[0].content.parts[0].text;
            console.log('Resposta do Gemini para imagem:', text);
            // Extrair JSON da resposta
            const jsonMatch = text.match(/\{[\s\S]*?\}/);
            if (!jsonMatch) {
                console.error('JSON n√£o encontrado na resposta do Gemini para imagem');
                return null;
            }
            let parsedData;
            try {
                parsedData = JSON.parse(jsonMatch[0]);
            } catch (parseError) {
                console.error('Erro ao fazer parse do JSON da imagem:', parseError);
                return null;
            }
            // Criar objeto BetData
            const betData = {
                id: `bet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                chatId,
                userId,
                username,
                message: caption || '[Imagem de aposta]',
                data: new Date(),
                jogo: parsedData.jogo || 'N√£o identificado',
                mercado: parsedData.mercado || 'Pendente',
                linha_da_aposta: parsedData.linha_da_aposta || 'N√£o identificado',
                odd_tipster: parseFloat(parsedData.odd_tipster) || 0,
                placar: parsedData.placar || '0-0',
                pegou: null,
                odd_real: null,
                resultado_aposta: 'Pendente'
            };
            return betData;
        } catch (error) {
            console.error('Erro ao analisar imagem com Gemini:', error);
            return null;
        }
    }
    static createConfirmationMessage(betData) {
        return `üéØ *Aposta detectada!*\n\n` + `üèÜ *Jogo:* ${betData.jogo}\n` + `üìä *Mercado:* ${betData.mercado}\n` + `üé≤ *Linha:* ${betData.linha_da_aposta}\n` + `üí∞ *Odd Tipster:* ${betData.odd_tipster}\n` + `‚öΩ *Placar:* ${betData.placar}\n\n` + `‚ùì Voc√™ pegou essa aposta? (Responda: sim/n√£o)`;
    }
}
}),
"[project]/src/lib/shared/bet-cache.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "SharedBetCache": ()=>SharedBetCache
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
const CACHE_FILE = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), '.bet-cache.json');
class SharedBetCache {
    static saveBet(key, betData) {
        try {
            let cache = {};
            if (__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(CACHE_FILE)) {
                const fileContent = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(CACHE_FILE, 'utf8');
                console.log(`üìñ Conte√∫do atual do cache: ${fileContent}`);
                cache = JSON.parse(fileContent);
            }
            cache[key] = betData;
            const newContent = JSON.stringify(cache, null, 2);
            __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].writeFileSync(CACHE_FILE, newContent);
            console.log(`üíæ Aposta salva no cache: ${key}`);
            console.log(`üíæ Cache agora cont√©m ${Object.keys(cache).length} apostas`);
        } catch (error) {
            console.error('‚ùå Erro ao salvar no cache:', error);
        }
    }
    static getBet(key) {
        console.log(`üîç [CACHE] Procurando chave: ${key}`);
        try {
            if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(CACHE_FILE)) {
                console.log('‚ùå [CACHE] Arquivo n√£o existe');
                return null;
            }
            const fileContent = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(CACHE_FILE, 'utf8');
            console.log(`üìñ [CACHE] Conte√∫do do arquivo: ${fileContent}`);
            const cache = JSON.parse(fileContent);
            const keys = Object.keys(cache);
            const result = cache[key] || null;
            console.log(`üìã [CACHE] Total de apostas: ${keys.length}`);
            console.log(`üìã [CACHE] Chaves dispon√≠veis: [${keys.join(', ')}]`);
            console.log(`üéØ [CACHE] Chave '${key}' encontrada: ${!!result}`);
            if (result) {
                console.log(`üìä [CACHE] Dados da aposta:`, {
                    jogo: result.jogo,
                    odd_tipster: result.odd_tipster,
                    timestamp: result.timestamp
                });
            } else {
                console.log(`‚ùå [CACHE] Chave '${key}' n√£o encontrada`);
                console.log(`üí° [CACHE] Chaves similares:`);
                keys.forEach((k)=>{
                    const similarity = k.includes(key.split('_')[0]) || k.includes(key.split('_')[1]);
                    if (similarity) {
                        console.log(`   - ${k} (similar)`);
                    }
                });
            }
            return result;
        } catch (error) {
            console.error('‚ùå [CACHE] Erro ao ler cache:', error);
            return null;
        }
    }
    static removeBet(key) {
        try {
            if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(CACHE_FILE)) return;
            // CORRE√á√ÉO: Tipar explicitamente o cache
            const cache = JSON.parse(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(CACHE_FILE, 'utf8'));
            delete cache[key];
            __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].writeFileSync(CACHE_FILE, JSON.stringify(cache, null, 2));
            console.log(`üóëÔ∏è Aposta removida do cache: ${key}`);
        } catch (error) {
            console.error('Erro ao remover do cache:', error);
        }
    }
}
}),
"[externals]/readline [external] (readline, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("readline", () => require("readline"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[project]/src/lib/telegram/gramjs-monitor.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$telegram$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/telegram/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$telegram$2f$sessions$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/telegram/sessions/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$telegram$2f$events$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/telegram/events/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$gemini$2f$parser$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/gemini/parser.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$shared$2f$bet$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/shared/bet-cache.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$input$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/input/dist/lib/index.js [app-route] (ecmascript)");
;
;
;
;
;
;
class GramJSMonitor {
    client;
    allowedChatIds;
    yourUserId;
    botToken;
    pendingBets = new Map();
    constructor(config){
        const stringSession = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$telegram$2f$sessions$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringSession"](config.session);
        this.client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$telegram$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TelegramClient"](stringSession, config.apiId, config.apiHash, {
            connectionRetries: 10,
            retryDelay: 5000,
            timeout: 30000,
            autoReconnect: true,
            useWSS: true,
            testServers: false,
            floodSleepThreshold: 60
        });
        this.allowedChatIds = new Set(config.allowedChatIds);
        this.yourUserId = config.yourUserId;
        this.botToken = config.botToken;
    }
    async start() {
        console.log('üöÄ Iniciando GramJS Monitor...');
        const startWithRetry = async (maxRetries = 5)=>{
            for(let attempt = 1; attempt <= maxRetries; attempt++){
                try {
                    await this.client.start({
                        phoneNumber: async ()=>process.env.TELEGRAM_PHONE_NUMBER,
                        password: async ()=>{
                            const password = process.env.TELEGRAM_PASSWORD;
                            if (password) return password;
                            return await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$input$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].text('Digite sua senha 2FA (se habilitada): ');
                        },
                        phoneCode: async ()=>{
                            return await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$input$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].text('Digite o c√≥digo de verifica√ß√£o recebido no Telegram: ');
                        },
                        onError: (err)=>{
                            console.error(`‚ùå Erro no cliente (tentativa ${attempt}):`, err);
                            if (attempt < maxRetries) {
                                console.log(`üîÑ Tentando reconectar em 10 segundos...`);
                            }
                        }
                    });
                    console.log('‚úÖ GramJS conectado! Configurando handlers...');
                    await this.setupEventHandlers();
                    console.log('üëÄ Monitorando grupos configurados...');
                    this.setupConnectionMonitoring();
                    return;
                } catch (error) {
                    console.error(`‚ùå Falha na tentativa ${attempt}:`, error);
                    if (attempt < maxRetries) {
                        await new Promise((resolve)=>setTimeout(resolve, 10000));
                    } else {
                        throw error;
                    }
                }
            }
        };
        await startWithRetry();
    }
    setupConnectionMonitoring() {
        setInterval(async ()=>{
            try {
                if (!this.client.connected) {
                    console.log('üîÑ Conex√£o perdida, tentando reconectar...');
                    await this.client.connect();
                }
            } catch (error) {
                console.error('‚ùå Erro ao verificar conex√£o:', error);
            }
        }, 30000);
    }
    async setupEventHandlers() {
        this.client.addEventHandler(async (event)=>{
            const message = event.message;
            if (!message || !message.peerId) return;
            const chatId = this.getChatId(message.peerId);
            if (!this.allowedChatIds.has(chatId.toString()) && chatId.toString() !== this.yourUserId) {
                return;
            }
            // Definir as vari√°veis que estavam faltando
            const isAllowedGroup = this.allowedChatIds.has(chatId.toString());
            const isPrivateFromUser = chatId.toString() === this.yourUserId;
            if (isAllowedGroup) {
                console.log(`üëÄ Nova mensagem no grupo monitorado: ${chatId}`);
                if (message.text) {
                    await this.processTextMessage(message, chatId);
                }
                if (message.photo) {
                    await this.processPhotoMessage(message, chatId);
                }
            } else if (isPrivateFromUser) {
                console.log(`üí¨ Mensagem privada recebida: ${message.text}`);
                // Aqui voc√™ pode processar a resposta da odd
                await this.processPrivateMessage(message);
            }
        }, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$telegram$2f$events$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NewMessage"]({}));
    }
    // CORRE√á√ÉO: Usar any para evitar problemas de tipagem
    async processTextMessage(message, chatId) {
        const messageText = message.text;
        const senderId = message.senderId?.toString() || '0';
        console.log(`üìù Analisando mensagem de texto: "${messageText}"`);
        try {
            if (!message.senderId) {
                console.log('‚ùå SenderId n√£o encontrado na mensagem');
                return;
            }
            // CORRE√á√ÉO: Usar any para evitar problemas de tipagem
            const sender = await this.client.getEntity(message.senderId);
            const username = sender.username || sender.firstName || 'Usu√°rio';
            const betData = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$gemini$2f$parser$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GeminiParser"].parseBetMessage(messageText || '', parseInt(chatId), parseInt(senderId), username);
            if (betData) {
                console.log('üéØ Aposta detectada no grupo!');
                await this.sendPrivateNotification(betData);
            }
        } catch (error) {
            console.error('‚ùå Erro ao processar mensagem de texto:', error);
        }
    }
    async processPhotoMessage(message, chatId) {
        const senderId = message.senderId?.toString() || '0';
        const caption = message.text || '';
        console.log('üì∏ Analisando imagem do grupo...');
        try {
            if (!message.senderId) {
                console.log('‚ùå SenderId n√£o encontrado na mensagem');
                return;
            }
            // CORRE√á√ÉO: Usar any para evitar problemas de tipagem
            const sender = await this.client.getEntity(message.senderId);
            const username = sender.username || sender.firstName || 'Usu√°rio';
            // CORRE√á√ÉO: Usar any para downloadMedia
            const imageBuffer = await this.client.downloadMedia(message.photo, {
                progressCallback: (progress)=>{
                    console.log(`üì• Download: ${Math.round(progress * 100)}%`);
                }
            });
            if (imageBuffer && Buffer.isBuffer(imageBuffer)) {
                const imageBase64 = imageBuffer.toString('base64');
                const imageUrl = `data:image/jpeg;base64,${imageBase64}`;
                const betData = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$gemini$2f$parser$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GeminiParser"].parseImageMessage(imageUrl, caption, parseInt(chatId), parseInt(senderId), username);
                if (betData) {
                    console.log('üéØ Aposta detectada na imagem do grupo!');
                    await this.sendPrivateNotification(betData);
                }
            }
        } catch (error) {
            console.error('‚ùå Erro ao processar imagem:', error);
        }
    }
    async sendPrivateNotification(betData) {
        const message = `üéØ **Aposta detectada no grupo!**\n\n` + `‚öΩ **Jogo:** ${betData.jogo}\n` + `‚öΩ **Placar:** ${betData.placar || '0-0'}\n` + `üìä **Mercado:** ${betData.mercado}\n` + `üìà **Linha:** ${betData.linha_da_aposta}\n` + `üí∞ **Odd Tipster:** ${betData.odd_tipster}\n\n` + `üíé **Responda esta mensagem com a odd real que voc√™ conseguiu**\n` + `(Digite 0 se n√£o conseguiu pegar a aposta)`;
        try {
            const response = await fetch(`https://api.telegram.org/bot${this.botToken}/sendMessage`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chat_id: this.yourUserId,
                    text: message,
                    parse_mode: 'Markdown'
                })
            });
            const result = await response.json();
            if (result.ok) {
                const botMessageId = result.result.message_id;
                // CORRE√á√ÉO: Usar yourUserId ao inv√©s de chat.id para consist√™ncia
                const betKey = `${this.yourUserId}_${botMessageId}`;
                this.pendingBets.set(betKey, betData);
                __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$shared$2f$bet$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SharedBetCache"].saveBet(betKey, betData);
                console.log(`üì§ Notifica√ß√£o enviada. Aguardando resposta para: ${betKey}`);
                console.log(`üíæ Aposta salva em ambos os caches: ${betKey}`);
                console.log(`üîç DEBUG - Chat ID: ${result.result.chat.id}, Your User ID: ${this.yourUserId}`);
            } else {
                console.error('‚ùå Erro na API do Telegram:', result);
            }
        } catch (error) {
            console.error('‚ùå Erro ao enviar notifica√ß√£o:', error);
        }
    }
    getPendingBet(betKey) {
        return this.pendingBets.get(betKey);
    }
    // NOVO: M√©todo para debug
    getPendingBetsCount() {
        return this.pendingBets.size;
    }
    // NOVO: M√©todo para listar todas as chaves
    getPendingBetsKeys() {
        return Array.from(this.pendingBets.keys());
    }
    removePendingBet(betKey) {
        this.pendingBets.delete(betKey);
        __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$shared$2f$bet$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SharedBetCache"].removeBet(betKey);
        console.log(`üóëÔ∏è Aposta removida de ambos os caches: ${betKey}`);
    }
    listPendingBets() {
        return Array.from(this.pendingBets.keys());
    }
    // CORRE√á√ÉO: Tipar corretamente o par√¢metro peerId
    getChatId(peerId) {
        if (peerId.className === 'PeerChannel') {
            return `-100${peerId.channelId}`;
        } else if (peerId.className === 'PeerChat') {
            return `-${peerId.chatId}`;
        } else if (peerId.className === 'PeerUser') {
            return peerId.userId?.toString() || '0';
        }
        return peerId.toString();
    }
    async getSessionString() {
        // CORRE√á√ÉO: Usar any para evitar problemas de tipagem
        return this.client.session.save();
    }
    async processPrivateMessage(message) {
        // Debug: Log completo do objeto message para inspe√ß√£o
        console.log('üîç DEBUG - Objeto message completo:', JSON.stringify(message, null, 2));
        // Verificar se √© uma resposta a uma mensagem do bot
        if (!message.replyTo) {
            console.log('üìù Mensagem privada n√£o √© uma resposta');
            return;
        }
        const repliedMessageId = message.replyTo.replyToMsgId;
        const betKey = `${this.yourUserId}_${repliedMessageId}`;
        console.log(`üîç Procurando aposta para chave: ${betKey}`);
        console.log(`üîç Chaves dispon√≠veis no monitor:`, this.getPendingBetsKeys());
        const betData = this.getPendingBet(betKey);
        if (betData && message.text) {
            console.log(`üí∞ Processando resposta da odd: ${message.text}`);
            console.log(`üìã Dados da aposta encontrada:`, betData);
            // IMPORTANTE: Delegar para o webhook para manter consist√™ncia
            // O webhook tem toda a l√≥gica de processamento e salvamento
            console.log('üîÑ Delegando processamento para o webhook...');
        // Manter a aposta no cache para o webhook processar
        // N√£o remover aqui, deixar o webhook fazer isso
        } else {
            console.log('‚ùå Aposta n√£o encontrada ou mensagem sem texto');
            console.log(`‚ùå Texto da mensagem: ${message.text}`);
            console.log(`‚ùå BetData encontrado: ${!!betData}`);
        }
    }
    async handleOddResponse(oddText, betKey, betData) {
        // Implementar a mesma l√≥gica do webhook aqui
        // Ou fazer uma chamada para o webhook com os dados
        console.log(`Processando odd: ${oddText} para aposta: ${betKey}`);
        // Remover da mem√≥ria ap√≥s processar
        this.removePendingBet(betKey);
    }
    async stop() {
        await this.client.disconnect();
        console.log('üîå GramJS Monitor desconectado');
    }
}
const __TURBOPACK__default__export__ = GramJSMonitor;
}),
"[project]/src/app/api/telegram/webhook/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "POST": ()=>POST
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sheets$2f$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/sheets/service.ts [app-route] (ecmascript)");
// NOVO: Import do GramJS monitor
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$telegram$2f$gramjs$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/telegram/gramjs-monitor.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$shared$2f$bet$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/shared/bet-cache.ts [app-route] (ecmascript)");
;
;
;
;
const sheetsConfig = {
    spreadsheetId: process.env.GOOGLE_SHEETS_ID,
    range: 'Apostas!A:J',
    credentials: {
        client_email: process.env.GOOGLE_CLIENT_EMAIL,
        private_key: (process.env.GOOGLE_PRIVATE_KEY || '').replace(/\\n/g, '\n')
    }
};
const sheetsService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sheets$2f$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](sheetsConfig);
// NOVO: Inst√¢ncia global do GramJS monitor
let gramjsMonitor = null;
// NOVO: Fun√ß√£o para conectar ao monitor existente
function setGramJSMonitor(monitor) {
    gramjsMonitor = monitor;
    console.log('üîó Monitor GramJS conectado ao webhook');
}
async function POST(request) {
    console.log('üîÑ Webhook recebido');
    // NOVO: Verificar e conectar monitor se necess√°rio
    if (!gramjsMonitor && process.env.TELEGRAM_SESSION_STRING) {
        console.log('üîó Monitor n√£o conectado. Tentando conectar...');
        try {
            const monitor = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$telegram$2f$gramjs$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
                apiId: parseInt(process.env.TELEGRAM_API_ID),
                apiHash: process.env.TELEGRAM_API_HASH,
                session: process.env.TELEGRAM_SESSION_STRING,
                allowedChatIds: process.env.MONITORED_CHAT_IDS.split(','),
                yourUserId: process.env.YOUR_USER_ID,
                botToken: process.env.TELEGRAM_BOT_TOKEN
            });
            setGramJSMonitor(monitor);
            console.log('‚úÖ Monitor GramJS conectado ao webhook');
        } catch (error) {
            console.error('‚ùå Erro ao conectar monitor:', error);
        }
    }
    console.log(`üîó Status do monitor: ${gramjsMonitor ? 'CONECTADO' : 'DESCONECTADO'}`);
    try {
        const update = await request.json();
        console.log('üì¶ Update recebido:', JSON.stringify(update, null, 2));
        // NOVO: Log detalhado
        console.log('üîç Tipo de update:', {
            hasMessage: !!update.message,
            hasText: !!update.message?.text,
            hasReplyTo: !!update.message?.reply_to_message,
            chatId: update.message?.chat?.id,
            userId: update.message?.from?.id,
            messageText: update.message?.text
        });
        const message = update.message;
        // Processar apenas respostas √†s notifica√ß√µes do bot
        if (update.message && update.message.text) {
            const chatId = update.message.chat.id;
            const userId = update.message.from.id;
            const messageText = update.message.text;
            console.log(`üì® Mensagem de ${userId}: "${messageText}"`);
            // NOVO: Verificar se √© uma resposta
            if (message.reply_to_message) {
                const repliedMessageId = message.reply_to_message.message_id;
                // CORRE√á√ÉO: Usar o ID da mensagem √† qual est√° respondendo
                const betKey = `${userId}_${repliedMessageId}`;
                console.log('üîç Debug da chave:');
                console.log('- chatId:', chatId);
                console.log('- userId:', userId);
                console.log('- repliedMessageId:', repliedMessageId);
                console.log('- betKey gerada:', betKey);
                // ADICIONAR: Log das chaves dispon√≠veis
                console.log('- Chaves no cache compartilhado:', Object.keys(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)").existsSync('.bet-cache.json') ? JSON.parse(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)").readFileSync('.bet-cache.json', 'utf8')) : {}));
                if (gramjsMonitor) {
                    console.log('- Chaves dispon√≠veis no monitor:', gramjsMonitor.getPendingBetsKeys());
                }
                console.log(`üîç Procurando aposta com chave: ${betKey}`);
                console.log(`üîç Monitor dispon√≠vel: ${!!gramjsMonitor}`);
                let betData = null;
                // Verificar primeiro no GramJS monitor (se dispon√≠vel)
                if (gramjsMonitor) {
                    betData = gramjsMonitor.getPendingBet(betKey);
                    console.log(`üìã Aposta encontrada no GramJS monitor: ${!!betData}`);
                    if (betData) {
                        console.log(`üìã Dados da aposta no monitor:`, betData);
                    }
                } else {
                    console.log('‚ö†Ô∏è GramJS monitor n√£o est√° dispon√≠vel!');
                }
                // Se n√£o encontrou no monitor, verificar no cache compartilhado
                if (!betData) {
                    console.log(`üîç Verificando cache compartilhado para: ${betKey}`);
                    betData = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$shared$2f$bet$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SharedBetCache"].getBet(betKey);
                    console.log(`üìã Aposta encontrada no cache compartilhado: ${!!betData}`);
                    if (betData) {
                        console.log(`üìã Dados da aposta no cache:`, betData);
                    }
                }
                // NOVO: Log do estado dos caches
                console.log('üìä Estado dos caches:');
                console.log('- Monitor pendingBets size:', gramjsMonitor ? gramjsMonitor.getPendingBetsCount() : 'N/A');
                console.log('- Cache file exists:', __turbopack_context__.r("[externals]/fs [external] (fs, cjs)").existsSync('.bet-cache.json'));
                if (betData) {
                    console.log('üí∞ Processando resposta √† notifica√ß√£o...');
                    await handleOddReply(update, betKey, betData);
                    // Remover de ambos os caches
                    if (gramjsMonitor) {
                        gramjsMonitor.removePendingBet(betKey);
                    }
                    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$shared$2f$bet$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SharedBetCache"].removeBet(betKey);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        ok: true,
                        processed: true
                    });
                } else {
                    console.log('‚ùå Nenhuma aposta pendente encontrada para esta resposta');
                    console.log('‚ùå Chave procurada:', betKey);
                    console.log('‚ùå Isso pode indicar que:');
                    console.log('   1. A aposta expirou ou foi removida');
                    console.log('   2. O monitor n√£o est√° funcionando');
                    console.log('   3. H√° um problema na gera√ß√£o da chave');
                }
            } else {
                console.log('‚ÑπÔ∏è Mensagem n√£o √© uma resposta (n√£o tem reply_to_message)');
            }
        } else {
            console.log('‚ÑπÔ∏è Update n√£o cont√©m mensagem de texto');
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true,
            processed: false
        });
    } catch (error) {
        console.error('‚ùå Erro no webhook:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Internal server error'
        }, {
            status: 500
        });
    }
}
// Fun√ß√£o para processar resposta da odd (corrigir tipagem)
async function handleOddReply(update, betKey, betData) {
    // Adicionar verifica√ß√µes de seguran√ßa
    if (!update?.message?.chat?.id || !update?.message?.text) {
        console.error('‚ùå Update inv√°lido recebido:', update);
        return;
    }
    const chatId = update.message.chat.id;
    const messageText = update.message.text.trim();
    console.log(`üìä Processando resposta da ODD: "${messageText}" para chave: ${betKey}`);
    const oddReal = parseFloat(messageText.replace(',', '.'));
    console.log(`üìä Odd recebida: ${messageText} -> ${oddReal}`);
    if (oddReal === 0) {
        // Aposta n√£o foi pega
        betData.pegou = false;
        betData.odd_real = null;
        console.log('üíæ Salvando aposta como N√ÉO PEGA no Google Sheets:', betData);
        const success = await sheetsService.addBetData(betData);
        if (success) {
            await sendTelegramMessage(chatId, `‚ùå **Aposta n√£o realizada**\n\n` + `‚öΩ **Jogo:** ${betData.jogo}\n` + `‚öΩ **Placar:** ${betData.placar || '0-0'}\n` + `üìä **Mercado:** ${betData.mercado}\n` + `üìà **Linha:** ${betData.linha_da_aposta}\n` + `üí∞ **Odd Tipster:** ${betData.odd_tipster}\n\n` + `‚úÖ Registrado que a aposta n√£o foi pega.`);
            console.log('‚úÖ Aposta marcada como n√£o realizada e salva com sucesso');
        } else {
            console.error('‚ùå Erro ao salvar aposta n√£o realizada');
            await sendTelegramMessage(chatId, `‚ùå **Erro ao salvar**\n\nHouve erro ao salvar no Google Sheets. Verifique os logs.`);
        }
    } else if (!isNaN(oddReal) && oddReal > 0) {
        // Aposta foi pega com odd v√°lida
        betData.pegou = true;
        betData.odd_real = oddReal;
        console.log('üíæ Salvando aposta PEGA no Google Sheets:', betData);
        const success = await sheetsService.addBetData(betData);
        if (success) {
            await sendTelegramMessage(chatId, `‚úÖ **Aposta registrada com sucesso!**\n\n` + `‚öΩ **Jogo:** ${betData.jogo}\n` + `‚öΩ **Placar:** ${betData.placar || '0-0'}\n` + `üìä **Mercado:** ${betData.mercado}\n` + `üìà **Linha:** ${betData.linha_da_aposta}\n` + `üí∞ **Odd Tipster:** ${betData.odd_tipster}\n` + `üíé **Odd Real:** ${betData.odd_real}\n` + `üìä **Status:** ${betData.resultado_aposta}`);
            console.log('‚úÖ Aposta salva com sucesso no Google Sheets');
        } else {
            console.error('‚ùå Erro ao salvar aposta no Google Sheets');
            await sendTelegramMessage(chatId, `‚ùå **Erro ao salvar**\n\nHouve erro ao salvar no Google Sheets. Verifique os logs.`);
        }
    } else {
        // Odd inv√°lida
        console.log(`‚ùå Odd inv√°lida recebida: ${messageText}`);
        await sendTelegramMessage(chatId, `‚ùå **Odd inv√°lida**\n\nPor favor, responda com um n√∫mero v√°lido ou 0 para \"n√£o peguei\".\n\nExemplos: 1.85, 2.50, 0`);
        return; // N√£o remove do cache
    }
}
async function sendTelegramMessage(chatId, text) {
    const botToken = process.env.TELEGRAM_BOT_TOKEN;
    try {
        console.log(`Enviando mensagem para chat ${chatId}:`, text);
        const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                chat_id: chatId,
                text: text,
                parse_mode: 'Markdown'
            })
        });
        const result = await response.json();
        if (!response.ok) {
            console.error('Erro na API do Telegram:', result);
        } else {
            console.log('Mensagem enviada com sucesso');
        }
        return result;
    } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
    }
}
async function getTelegramFileUrl(fileId) {
    const response = await fetch(`https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/getFile?file_id=${fileId}`);
    const data = await response.json();
    return `https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${data.result.file_path}`;
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__6e4487ce._.js.map