module.exports = {

"[project]/.next-internal/server/app/api/telegram/webhook/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/http2 [external] (http2, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[project]/src/lib/sheets/service.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/googleapis/build/src/index.js [app-route] (ecmascript)");
;
class GoogleSheetsService {
    sheets;
    auth;
    config;
    constructor(config){
        this.config = config;
        this.initializeAuth();
    }
    async initializeAuth() {
        try {
            this.auth = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].auth.GoogleAuth({
                credentials: this.config.credentials,
                scopes: [
                    'https://www.googleapis.com/auth/spreadsheets'
                ]
            });
            this.sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
                version: 'v4',
                auth: this.auth
            });
        } catch (error) {
            console.error('Erro ao inicializar autenticação Google Sheets:', error);
            throw error;
        }
    }
    async addBetData(betData) {
        try {
            console.log('Dados recebidos para salvar:', betData);
            const values = this.formatBetDataForSheets(betData);
            console.log('Valores formatados:', values);
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: this.config.range,
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values: [
                        values
                    ]
                }
            };
            console.log('Enviando para Google Sheets:', request);
            const response = await this.sheets.spreadsheets.values.append(request);
            console.log('Resposta do Google Sheets:', response.status, response.statusText);
            if (response.status === 200) {
                console.log('✅ Dados adicionados com sucesso ao Google Sheets');
                return true;
            }
            console.error('❌ Falha ao adicionar dados - Status:', response.status);
            return false;
        } catch (error) {
            console.error('❌ Erro ao adicionar dados ao Google Sheets:', error);
            if (error instanceof Error && error.response) {
                console.error('Detalhes do erro:', error.response.data);
            }
            return false;
        }
    }
    async addMultipleBetData(betDataArray) {
        if (betDataArray.length === 0) return 0;
        try {
            const values = betDataArray.map((bet)=>this.formatBetDataForSheets(bet));
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: this.config.range,
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values
                }
            };
            const response = await this.sheets.spreadsheets.values.append(request);
            if (response.status === 200) {
                console.log(`${betDataArray.length} registros adicionados com sucesso`);
                return betDataArray.length;
            }
            return 0;
        } catch (error) {
            console.error('Erro ao adicionar múltiplos dados:', error);
            return 0;
        }
    }
    formatBetDataForSheets(betData) {
        // Formatação corrigida para a estrutura real da planilha
        return [
            betData.data instanceof Date ? betData.data.toLocaleString('pt-BR') : new Date(betData.data).toLocaleString('pt-BR'),
            betData.jogo,
            betData.placar || '0-0',
            betData.linha_da_aposta,
            betData.mercado,
            typeof betData.odd_tipster === 'number' ? betData.odd_tipster.toString() : betData.odd_tipster,
            betData.pegou === true ? 'SIM' : betData.pegou === false ? 'NÃO' : 'PENDENTE',
            betData.odd_real ? betData.odd_real.toString() : '',
            '',
            betData.resultado_aposta || 'Pendente'
        ];
    }
    async createHeaderRow() {
        try {
            const headers = [
                'Data',
                'Jogo',
                'Placar',
                'Linha_da_Aposta',
                'Mercado',
                'Odd_Tipster',
                'Pegou',
                'Odd_Real',
                'Resultado_Jogo',
                'Resultado_Aposta' // J
            ];
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: 'A1:J1',
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values: [
                        headers
                    ]
                }
            };
            const response = await this.sheets.spreadsheets.values.update(request);
            console.log('Cabeçalho criado:', response.status === 200 ? 'Sucesso' : 'Falha');
            return response.status === 200;
        } catch (error) {
            console.error('Erro ao criar cabeçalho:', error);
            return false;
        }
    }
    async getSheetData(range) {
        try {
            const response = await this.sheets.spreadsheets.values.get({
                spreadsheetId: this.config.spreadsheetId,
                range: range || this.config.range
            });
            return response.data.values || [];
        } catch (error) {
            console.error('Erro ao buscar dados da planilha:', error);
            return [];
        }
    }
    // Método para testar a conexão
    async testConnection() {
        try {
            const response = await this.sheets.spreadsheets.get({
                spreadsheetId: this.config.spreadsheetId
            });
            console.log('✅ Conexão com Google Sheets OK:', response.data.properties.title);
            return true;
        } catch (error) {
            console.error('❌ Erro na conexão com Google Sheets:', error);
            return false;
        }
    }
}
const __TURBOPACK__default__export__ = GoogleSheetsService;
}),
"[project]/src/lib/gemini/parser.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GeminiParser": ()=>GeminiParser
});
class GeminiParser {
    static API_KEY = process.env.GEMINI_API_KEY;
    static API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';
    static async parseBetMessage(message, chatId, userId, username) {
        if (!this.API_KEY) {
            console.error('GEMINI_API_KEY não configurada');
            return null;
        }
        try {
            const prompt = `
Analise esta mensagem de aposta do Telegram e extraia as informações em formato JSON válido.

Mensagem: "${message}"

Você deve extrair:
- jogo: Os times que estão jogando (formato: "Time A vs Time B")
- mercado: Tipo de aposta ("Goal Line", "Asian Handicap", "Resultado Final", "Over/Under", etc.)
- linha_da_aposta: A linha específica da aposta (ex: "GL +0.5", "AH -1.0", "Over 2.5", etc.)
- odd_tipster: A odd fornecida pelo tipster (apenas o número, ex: "1.85")
- placar: O placar atual do jogo se mencionado na mensagem (ex: "2x1", "1-0", "3x2"). Se não houver placar ou o jogo não tiver começado, use "0-0"

Exemplos de formato para linha_da_aposta:
- Goal Line: "GL +0.5", "GL -1.0", "GL 0.0"
- Asian Handicap: "AH +1.5", "AH -0.5", "AH 0.0"
- Over/Under: "Over 2.5", "Under 1.5"
- Resultado: "1", "X", "2"

Exemplos de placar:
- Se a mensagem menciona "Flamengo 2x1 Palmeiras" → placar: "2x1"
- Se a mensagem menciona "jogo começou 1-0" → placar: "1x0"
- Se não menciona placar ou diz "jogo às 20h" → placar: "0-0"

Retorne APENAS um JSON válido no formato:
{
  "jogo": "Time A vs Time B",
  "mercado": "Goal Line",
  "linha_da_aposta": "GL +0.5",
  "odd_tipster": "1.85",
  "placar": "2x1" ou "0-0"
}

Se não conseguir extrair alguma informação, use null para esse campo (exceto placar que deve ser "0-0").`;
            const response = await fetch(`${this.API_URL}?key=${this.API_KEY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [
                        {
                            parts: [
                                {
                                    text: prompt
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: 0.1,
                        maxOutputTokens: 300
                    }
                })
            });
            if (!response.ok) {
                const errorText = await response.text();
                console.error('Erro na API do Gemini:', response.status, response.statusText, errorText);
                return null;
            }
            const result = await response.json();
            if (!result.candidates || result.candidates.length === 0) {
                console.error('Nenhuma resposta do Gemini');
                return null;
            }
            const text = result.candidates[0].content.parts[0].text;
            console.log('Resposta do Gemini:', text);
            // Extrair JSON da resposta
            const jsonMatch = text.match(/\{[\s\S]*?\}/);
            if (!jsonMatch) {
                console.error('JSON não encontrado na resposta do Gemini');
                return null;
            }
            let parsedData;
            try {
                parsedData = JSON.parse(jsonMatch[0]);
            } catch (parseError) {
                console.error('Erro ao fazer parse do JSON:', parseError);
                return null;
            }
            // Validar dados essenciais
            if (!parsedData.jogo || !parsedData.odd_tipster) {
                console.error('Dados essenciais não encontrados');
                return null;
            }
            return {
                id: `${chatId}_${userId}_${Date.now()}`,
                chatId,
                userId,
                username,
                message,
                data: new Date(),
                jogo: parsedData.jogo,
                mercado: parsedData.mercado || 'Pendente',
                linha_da_aposta: parsedData.linha_da_aposta || 'Não identificado',
                odd_tipster: parseFloat(parsedData.odd_tipster),
                placar: parsedData.placar || '0-0',
                pegou: null,
                odd_real: null,
                resultado_aposta: 'Pendente'
            };
        } catch (error) {
            console.error('Erro ao processar mensagem com Gemini:', error);
            return null;
        }
    }
    static async parseImageMessage(imageUrl, caption, chatId, userId, username) {
        if (!this.API_KEY) {
            console.error('GEMINI_API_KEY não configurada');
            return null;
        }
        try {
            console.log('🖼️ Analisando imagem com Gemini:', imageUrl);
            // Baixar a imagem e converter para base64
            const imageResponse = await fetch(imageUrl);
            if (!imageResponse.ok) {
                console.error('Erro ao baixar imagem:', imageResponse.status);
                return null;
            }
            const imageBuffer = await imageResponse.arrayBuffer();
            const base64Image = Buffer.from(imageBuffer).toString('base64');
            const prompt = `
Analise esta imagem de aposta esportiva e extraia as informações em formato JSON válido.

${caption ? `Legenda da imagem: "${caption}"` : ''}

Você deve extrair:
- jogo: Os times que estão jogando (formato: "Time A vs Time B")
- mercado: Tipo de aposta ("Goal Line", "Asian Handicap", "Resultado Final", "Over/Under", etc.)
- linha_da_aposta: A linha específica da aposta (ex: "GL +0.5", "AH -1.0", "Over 2.5", etc.)
- odd_tipster: A odd fornecida pelo tipster (apenas o número, ex: "1.85")
- placar: O placar atual do jogo se visível na imagem (ex: "2x1", "1-0", "3x2"). Se não houver placar ou o jogo não tiver começado, use "0-0"

Exemplos de formato para linha_da_aposta:
- Goal Line: "GL +0.5", "GL -1.0", "GL 0.0"
- Asian Handicap: "AH +1.5", "AH -0.5", "AH 0.0"
- Over/Under: "Over 2.5", "Under 1.5"
- Resultado: "1", "X", "2"

Retorne APENAS um JSON válido no formato:
{
  "jogo": "Time A vs Time B",
  "mercado": "Goal Line",
  "linha_da_aposta": "GL +0.5",
  "odd_tipster": "1.85",
  "placar": "2x1" ou "0-0"
}

Se não conseguir extrair alguma informação, use null para esse campo (exceto placar que deve ser "0-0").`;
            const response = await fetch(`${this.API_URL}?key=${this.API_KEY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [
                        {
                            parts: [
                                {
                                    text: prompt
                                },
                                {
                                    inline_data: {
                                        mime_type: 'image/jpeg',
                                        data: base64Image
                                    }
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: 0.1,
                        maxOutputTokens: 300
                    }
                })
            });
            if (!response.ok) {
                const errorText = await response.text();
                console.error('Erro na API do Gemini:', response.status, response.statusText, errorText);
                return null;
            }
            const result = await response.json();
            if (!result.candidates || result.candidates.length === 0) {
                console.error('Nenhuma resposta do Gemini para imagem');
                return null;
            }
            const text = result.candidates[0].content.parts[0].text;
            console.log('Resposta do Gemini para imagem:', text);
            // Extrair JSON da resposta
            const jsonMatch = text.match(/\{[\s\S]*?\}/);
            if (!jsonMatch) {
                console.error('JSON não encontrado na resposta do Gemini para imagem');
                return null;
            }
            let parsedData;
            try {
                parsedData = JSON.parse(jsonMatch[0]);
            } catch (parseError) {
                console.error('Erro ao fazer parse do JSON da imagem:', parseError);
                return null;
            }
            // Criar objeto BetData
            const betData = {
                id: `bet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                chatId,
                userId,
                username,
                message: caption || '[Imagem de aposta]',
                data: new Date(),
                jogo: parsedData.jogo || 'Não identificado',
                mercado: parsedData.mercado || 'Pendente',
                linha_da_aposta: parsedData.linha_da_aposta || 'Não identificado',
                odd_tipster: parseFloat(parsedData.odd_tipster) || 0,
                placar: parsedData.placar || '0-0',
                pegou: null,
                odd_real: null,
                resultado_aposta: 'Pendente'
            };
            return betData;
        } catch (error) {
            console.error('Erro ao analisar imagem com Gemini:', error);
            return null;
        }
    }
    static createConfirmationMessage(betData) {
        return `🎯 *Aposta detectada!*\n\n` + `🏆 *Jogo:* ${betData.jogo}\n` + `📊 *Mercado:* ${betData.mercado}\n` + `🎲 *Linha:* ${betData.linha_da_aposta}\n` + `💰 *Odd Tipster:* ${betData.odd_tipster}\n` + `⚽ *Placar:* ${betData.placar}\n\n` + `❓ Você pegou essa aposta? (Responda: sim/não)`;
    }
}
}),
"[project]/src/app/api/telegram/webhook/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GET": ()=>GET,
    "POST": ()=>POST
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sheets$2f$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/sheets/service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$gemini$2f$parser$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/gemini/parser.ts [app-route] (ecmascript)");
;
;
;
const sheetsConfig = {
    spreadsheetId: process.env.GOOGLE_SHEETS_ID,
    range: 'Apostas!A:J',
    credentials: {
        client_email: process.env.GOOGLE_CLIENT_EMAIL,
        private_key: (process.env.GOOGLE_PRIVATE_KEY || '').replace(/\\n/g, '\n')
    }
};
const sheetsService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sheets$2f$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](sheetsConfig);
// Cache para armazenar apostas por message_id do bot
const pendingBets = new Map();
async function GET() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        status: 'Webhook ativo! 🤖',
        timestamp: new Date().toISOString(),
        message: 'Este endpoint está funcionando corretamente para receber webhooks do Telegram.'
    });
}
async function POST(request) {
    console.log('🔄 Webhook recebido');
    try {
        const update = await request.json();
        console.log('📦 Update recebido:', JSON.stringify(update, null, 2));
        const message = update.message;
        // NOVO: Processar mensagens com foto
        if (message && message.photo) {
            console.log('📸 Imagem recebida, processando...');
            const chatId = message.chat.id;
            const userId = message.from.id;
            const username = message.from.username;
            // Pegar a foto de maior resolução
            const photo = message.photo[message.photo.length - 1];
            const fileId = photo.file_id;
            console.log(`📷 Processando imagem de ${username} (${userId}), fileId: ${fileId}`);
            try {
                // Obter URL da imagem
                const imageUrl = await getTelegramFileUrl(fileId);
                console.log('🔗 URL da imagem:', imageUrl);
                // Processar com Gemini AI
                console.log('🤖 Analisando imagem com Gemini AI...');
                const betData = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$gemini$2f$parser$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GeminiParser"].parseImageMessage(imageUrl, message.caption || '', chatId, userId, username);
                console.log('🎯 Resultado da análise da imagem:', betData);
                if (betData) {
                    console.log('✅ Aposta detectada na imagem pela IA:', betData);
                    // Enviar mensagem perguntando a odd
                    const sentMessage = await sendTelegramMessage(chatId, `🎯 **Aposta detectada na imagem!**\n\n` + `⚽ **Jogo:** ${betData.jogo}\n` + `⚽ **Placar:** ${betData.placar}\n` + `📊 **Mercado:** ${betData.mercado}\n` + `📈 **Linha:** ${betData.linha_da_aposta}\n` + `💰 **Odd Tipster:** ${betData.odd_tipster}\n\n` + `💎 **Responda esta mensagem com a odd real que você conseguiu**\n` + `(Digite 0 se não conseguiu pegar a aposta)`);
                    // Salvar aposta usando o message_id da resposta do bot
                    if (sentMessage && sentMessage.result) {
                        const botMessageId = sentMessage.result.message_id;
                        const betKey = `${chatId}_${botMessageId}`;
                        pendingBets.set(betKey, betData);
                        console.log(`📤 Aposta da imagem salva com chave: ${betKey}`);
                    }
                } else {
                    console.log('❌ Imagem não reconhecida como aposta válida pela IA');
                    await sendTelegramMessage(chatId, '🤖 Recebi sua imagem, mas não consegui identificar uma aposta. Logs disponíveis no servidor.');
                }
            } catch (error) {
                console.error('❌ Erro ao processar imagem:', error);
                await sendTelegramMessage(chatId, '❌ **Erro ao processar imagem**\n\nHouve um problema ao analisar sua imagem. Tente novamente.');
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: true
            });
        }
        // Processar mensagens de texto
        if (update.message && update.message.text) {
            const chatId = update.message.chat.id;
            const userId = update.message.from.id;
            const username = update.message.from.username;
            const messageText = update.message.text;
            const messageId = update.message.message_id;
            console.log(`📨 Mensagem de ${username} (${userId}): "${messageText}"`);
            // 1. Verificar se é uma resposta (reply) a uma mensagem de aposta
            if (message.reply_to_message) {
                const repliedMessageId = message.reply_to_message.message_id;
                const betKey = `${chatId}_${repliedMessageId}`;
                if (pendingBets.has(betKey)) {
                    console.log('💰 Processando odd em resposta à aposta...');
                    await handleOddReply(update, betKey);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        ok: true
                    });
                }
            }
            // 2. Processar nova mensagem de aposta com IA
            console.log('🤖 Analisando mensagem com Gemini AI...');
            console.log('🔑 GEMINI_API_KEY configurada:', !!process.env.GEMINI_API_KEY);
            const betData = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$gemini$2f$parser$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GeminiParser"].parseBetMessage(messageText, chatId, userId, username);
            console.log('🎯 Resultado da análise:', betData);
            if (betData) {
                console.log('✅ Nova aposta detectada pela IA:', betData);
                // Enviar mensagem perguntando a odd
                const sentMessage = await sendTelegramMessage(chatId, `🎯 **Aposta detectada!**\n\n` + `⚽ **Jogo:** ${betData.jogo}\n` + `⚽ **Placar:** ${betData.placar}\n` + `📊 **Mercado:** ${betData.mercado}\n` + `📈 **Linha:** ${betData.linha_da_aposta}\n` + `💰 **Odd Tipster:** ${betData.odd_tipster}\n\n` + `💎 **Responda esta mensagem com a odd real que você conseguiu**\n` + `(Digite 0 se não conseguiu pegar a aposta)`);
                // Salvar aposta usando o message_id da resposta do bot
                if (sentMessage && sentMessage.result) {
                    const botMessageId = sentMessage.result.message_id;
                    const betKey = `${chatId}_${botMessageId}`;
                    pendingBets.set(betKey, betData);
                    console.log(`📤 Aposta salva com chave: ${betKey}`);
                }
            } else {
                console.log('❌ Mensagem não reconhecida como aposta válida pela IA');
                await sendTelegramMessage(chatId, '🤖 Recebi sua mensagem, mas não consegui identificar uma aposta. Logs disponíveis no servidor.');
            }
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true
        });
    } catch (error) {
        console.error('❌ Erro no webhook:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Internal server error'
        }, {
            status: 500
        });
    }
}
async function handleOddReply(update, betKey) {
    const chatId = update.message.chat.id;
    const messageText = update.message.text.trim();
    const betData = pendingBets.get(betKey);
    if (!betData) {
        console.log('❌ Dados da aposta não encontrados');
        await sendTelegramMessage(chatId, '❌ **Aposta não encontrada**\n\nEsta aposta pode ter expirado ou já foi processada.');
        return;
    }
    const oddReal = parseFloat(messageText.replace(',', '.'));
    console.log(`📊 Odd recebida: ${messageText} -> ${oddReal}`);
    if (oddReal === 0) {
        // Aposta não foi pega
        betData.pegou = false;
        betData.odd_real = null;
        // Salvar no Google Sheets mesmo quando não pegou
        const success = await sheetsService.addBetData(betData);
        await sendTelegramMessage(chatId, `❌ **Aposta não realizada**\n\n` + `⚽ **Jogo:** ${betData.jogo}\n` + `⚽ **Placar:** ${betData.placar}\n` + `📊 **Mercado:** ${betData.mercado}\n` + `📈 **Linha:** ${betData.linha_da_aposta}\n` + `💰 **Odd Tipster:** ${betData.odd_tipster}\n\n` + `Registrado que a aposta não foi pega.`);
        console.log('❌ Aposta marcada como não realizada');
    } else if (!isNaN(oddReal) && oddReal > 0) {
        // Aposta foi pega com odd válida
        betData.pegou = true;
        betData.odd_real = oddReal;
        console.log('💾 Salvando aposta no Google Sheets:', betData);
        // Testar conexão e salvar
        const connectionOk = await sheetsService.testConnection();
        if (!connectionOk) {
            console.error('❌ Falha na conexão com Google Sheets');
            await sendTelegramMessage(chatId, '❌ **Erro de conexão**\n\nNão foi possível conectar ao Google Sheets.');
            return;
        }
        const success = await sheetsService.addBetData(betData);
        if (success) {
            await sendTelegramMessage(chatId, `✅ **Aposta registrada com sucesso!**\n\n` + `⚽ **Jogo:** ${betData.jogo}\n` + `⚽ **Placar:** ${betData.placar}\n` + `📊 **Mercado:** ${betData.mercado}\n` + `📈 **Linha:** ${betData.linha_da_aposta}\n` + `💰 **Odd Tipster:** ${betData.odd_tipster}\n` + `💎 **Odd Real:** ${betData.odd_real}\n` + `📊 **Status:** ${betData.resultado_aposta}`);
            console.log('✅ Aposta salva com sucesso');
        } else {
            await sendTelegramMessage(chatId, `❌ **Erro ao salvar**\n\nHouve erro ao salvar no Google Sheets. Verifique os logs.`);
            console.error('❌ Falha ao salvar no Google Sheets');
        }
    } else {
        // Odd inválida
        await sendTelegramMessage(chatId, `❌ **Odd inválida**\n\nPor favor, responda com um número válido ou 0 para \"não peguei\".\n\nExemplos: 1.85, 2.50, 0`);
        console.log('❌ Odd inválida, aguardando nova resposta');
        return; // Não remove do cache, aguarda nova resposta
    }
    // Remove do cache após processar
    pendingBets.delete(betKey);
    console.log(`🗑️ Aposta removida do cache: ${betKey}`);
}
async function sendTelegramMessage(chatId, text) {
    const botToken = process.env.TELEGRAM_BOT_TOKEN;
    try {
        console.log(`Enviando mensagem para chat ${chatId}:`, text);
        const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                chat_id: chatId,
                text: text,
                parse_mode: 'Markdown'
            })
        });
        const result = await response.json();
        if (!response.ok) {
            console.error('Erro na API do Telegram:', result);
        } else {
            console.log('Mensagem enviada com sucesso');
        }
        return result;
    } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
    }
}
async function getTelegramFileUrl(fileId) {
    const response = await fetch(`https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/getFile?file_id=${fileId}`);
    const data = await response.json();
    return `https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${data.result.file_path}`;
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__d6ab3e2b._.js.map