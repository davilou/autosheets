{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documentos/Trae/autosheets%20backup%202%20-%20Copia/src/lib/sheets/service.ts"],"sourcesContent":["import { google } from 'googleapis';\r\nimport { BetData } from '../telegram/parser'; // Mudança aqui!\r\nimport { SHEETS_CONFIG } from '../security/config';\r\n\r\ninterface SheetsConfig {\r\n  spreadsheetId: string;\r\n  range: string;\r\n  credentials: {\r\n    client_email: string;\r\n    private_key: string;\r\n  };\r\n}\r\n\r\nclass GoogleSheetsService {\r\n  private sheets: any;\r\n  private auth: any;\r\n  private config: SheetsConfig;\r\n\r\n  constructor(config: SheetsConfig) {\r\n    this.config = config;\r\n    this.initializeAuth();\r\n  }\r\n\r\n  private async initializeAuth() {\r\n    try {\r\n      this.auth = new google.auth.GoogleAuth({\r\n        credentials: this.config.credentials,\r\n        scopes: ['https://www.googleapis.com/auth/spreadsheets'],\r\n      });\r\n\r\n      this.sheets = google.sheets({ version: 'v4', auth: this.auth });\r\n    } catch (error) {\r\n      console.error('Erro ao inicializar autenticação Google Sheets:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async addBetData(betData: BetData): Promise<boolean> {\r\n    try {\r\n      console.log('Dados recebidos para salvar:', betData);\r\n      \r\n      const values = this.formatBetDataForSheets(betData);\r\n      console.log('Valores formatados:', values);\r\n      \r\n      const request = {\r\n        spreadsheetId: this.config.spreadsheetId,\r\n        range: this.config.range,\r\n        valueInputOption: 'USER_ENTERED',\r\n        resource: {\r\n          values: [values],\r\n        },\r\n      };\r\n\r\n      console.log('Enviando para Google Sheets:', request);\r\n      const response = await this.sheets.spreadsheets.values.append(request);\r\n      \r\n      console.log('Resposta do Google Sheets:', response.status, response.statusText);\r\n      \r\n      if (response.status === 200) {\r\n        console.log('✅ Dados adicionados com sucesso ao Google Sheets');\r\n        return true;\r\n      }\r\n      \r\n      console.error('❌ Falha ao adicionar dados - Status:', response.status);\r\n      return false;\r\n    } catch (error) {\r\n      console.error('❌ Erro ao adicionar dados ao Google Sheets:', error);\r\n      if (error instanceof Error && (error as any).response) {\r\n        console.error('Detalhes do erro:', (error as any).response.data);\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async addMultipleBetData(betDataArray: BetData[]): Promise<number> {\r\n    if (betDataArray.length === 0) return 0;\r\n    \r\n    try {\r\n      const values = betDataArray.map(bet => this.formatBetDataForSheets(bet));\r\n      \r\n      const request = {\r\n        spreadsheetId: this.config.spreadsheetId,\r\n        range: this.config.range,\r\n        valueInputOption: 'USER_ENTERED',\r\n        resource: {\r\n          values,\r\n        },\r\n      };\r\n\r\n      const response = await this.sheets.spreadsheets.values.append(request);\r\n      \r\n      if (response.status === 200) {\r\n        console.log(`${betDataArray.length} registros adicionados com sucesso`);\r\n        return betDataArray.length;\r\n      }\r\n      \r\n      return 0;\r\n    } catch (error) {\r\n      console.error('Erro ao adicionar múltiplos dados:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  private formatBetDataForSheets(betData: BetData): any[] {\r\n    // Formatação corrigida para a estrutura real da planilha\r\n    return [\r\n      betData.data instanceof Date \r\n        ? betData.data.toLocaleString('pt-BR') \r\n        : new Date(betData.data).toLocaleString('pt-BR'),    // A - Data\r\n      betData.jogo,                                         // B - Jogo\r\n      betData.placar || '0-0',                              // C - Placar (MUDANÇA: usar \"0-0\" como padrão)\r\n      betData.linha_da_aposta,                              // D - Linha_da_Aposta\r\n      betData.mercado,                                      // E - Mercado\r\n      typeof betData.odd_tipster === 'number' \r\n        ? betData.odd_tipster.toString() \r\n        : betData.odd_tipster,                              // F - Odd_Tipster\r\n      betData.pegou === true ? 'SIM' : \r\n      betData.pegou === false ? 'NÃO' : 'PENDENTE',        // G - Pegou\r\n      betData.odd_real ? betData.odd_real.toString() : '', // H - Odd_Real\r\n      '',                                                   // I - Resultado_Jogo (vazio inicialmente)\r\n      betData.resultado_aposta || 'Pendente',               // J - Resultado_Aposta\r\n    ];\r\n  }\r\n\r\n  async createHeaderRow(): Promise<boolean> {\r\n    try {\r\n      const headers = [\r\n        'Data',                  // A\r\n        'Jogo',                  // B\r\n        'Placar',                // C\r\n        'Linha_da_Aposta',       // D\r\n        'Mercado',               // E\r\n        'Odd_Tipster',           // F\r\n        'Pegou',                 // G\r\n        'Odd_Real',              // H\r\n        'Resultado_Jogo',        // I\r\n        'Resultado_Aposta'       // J\r\n      ];\r\n  \r\n      const request = {\r\n        spreadsheetId: this.config.spreadsheetId,\r\n        range: 'A1:J1',\r\n        valueInputOption: 'USER_ENTERED',\r\n        resource: {\r\n          values: [headers],\r\n        },\r\n      };\r\n  \r\n      const response = await this.sheets.spreadsheets.values.update(request);\r\n      console.log('Cabeçalho criado:', response.status === 200 ? 'Sucesso' : 'Falha');\r\n      return response.status === 200;\r\n    } catch (error) {\r\n      console.error('Erro ao criar cabeçalho:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getSheetData(range?: string): Promise<any[]> {\r\n    try {\r\n      const response = await this.sheets.spreadsheets.values.get({\r\n        spreadsheetId: this.config.spreadsheetId,\r\n        range: range || this.config.range,\r\n      });\r\n\r\n      return response.data.values || [];\r\n    } catch (error) {\r\n      console.error('Erro ao buscar dados da planilha:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Método para testar a conexão\r\n  async testConnection(): Promise<boolean> {\r\n    try {\r\n      const response = await this.sheets.spreadsheets.get({\r\n        spreadsheetId: this.config.spreadsheetId\r\n      });\r\n      \r\n      console.log('✅ Conexão com Google Sheets OK:', response.data.properties.title);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('❌ Erro na conexão com Google Sheets:', error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nexport default GoogleSheetsService;\r\nexport type { SheetsConfig };"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 381, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documentos/Trae/autosheets%20backup%202%20-%20Copia/src/lib/gemini/parser.ts"],"sourcesContent":["import dotenv from 'dotenv';\r\nimport path from 'path';\r\nimport { BetData } from '../telegram/parser';\r\n\r\n// Carregar variáveis de ambiente\r\ndotenv.config({ path: path.join(process.cwd(), '.env.local') });\r\n\r\ninterface GeminiResponse {\r\n  candidates: {\r\n    content: {\r\n      parts: {\r\n        text: string;\r\n      }[];\r\n    };\r\n  }[];\r\n}\r\n\r\nexport class GeminiParser {\r\n  private static readonly API_KEY = process.env.GEMINI_API_KEY;\r\n  private static readonly API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';\r\n\r\n  static async parseBetMessage(message: string, chatId: number, userId: number, username: string): Promise<BetData | null> {\r\n    if (!this.API_KEY) {\r\n      console.error('❌ GEMINI_API_KEY não configurada no .env.local');\r\n      console.error('Verifique se a variável GEMINI_API_KEY está presente no arquivo .env.local');\r\n      return null;\r\n    }\r\n\r\n    console.log('✅ GEMINI_API_KEY carregada com sucesso');\r\n    \r\n    try {\r\n      const prompt = `\r\nAnalise esta mensagem de aposta do Telegram e extraia as informações em formato JSON válido.\r\n\r\nMensagem: \"${message}\"\r\n\r\nVocê deve extrair:\r\n- jogo: Os times que estão jogando (formato: \"Time A vs Time B\")\r\n- mercado: Tipo de aposta (\"Goal Line\", \"Asian Handicap\", \"Resultado Final\", \"Over/Under\", etc.)\r\n- linha_da_aposta: A linha específica da aposta (ex: \"GL +0.5\", \"AH -1.0\", \"Over 2.5\", etc.)\r\n- odd_tipster: A odd fornecida pelo tipster (apenas o número, ex: \"1.85\")\r\n- placar: O placar atual do jogo se mencionado na mensagem (ex: \"2x1\", \"1-0\", \"3x2\"). Se não houver placar ou o jogo não tiver começado, use \"0-0\"\r\n\r\nExemplos de formato para linha_da_aposta:\r\n- Goal Line: \"GL +0.5\", \"GL -1.0\", \"GL 0.0\"\r\n- Asian Handicap: \"AH +1.5\", \"AH -0.5\", \"AH 0.0\"\r\n- Over/Under: \"Over 2.5\", \"Under 1.5\"\r\n- Resultado: \"1\", \"X\", \"2\"\r\n\r\nExemplos de placar:\r\n- Se a mensagem menciona \"Flamengo 2x1 Palmeiras\" → placar: \"2x1\"\r\n- Se a mensagem menciona \"jogo começou 1-0\" → placar: \"1x0\"\r\n- Se não menciona placar ou diz \"jogo às 20h\" → placar: \"0-0\"\r\n\r\nRetorne APENAS um JSON válido no formato:\r\n{\r\n  \"jogo\": \"Time A vs Time B\",\r\n  \"mercado\": \"Goal Line\",\r\n  \"linha_da_aposta\": \"GL +0.5\",\r\n  \"odd_tipster\": \"1.85\",\r\n  \"placar\": \"2x1\" ou \"0-0\"\r\n}\r\n\r\nSe não conseguir extrair alguma informação, use null para esse campo (exceto placar que deve ser \"0-0\").`;\r\n\r\n      const response = await fetch(`${this.API_URL}?key=${this.API_KEY}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          contents: [{\r\n            parts: [{\r\n              text: prompt\r\n            }]\r\n          }],\r\n          generationConfig: {\r\n            temperature: 0.1,\r\n            maxOutputTokens: 300,\r\n          }\r\n        })\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        console.error('Erro na API do Gemini:', response.status, response.statusText, errorText);\r\n        return null;\r\n      }\r\n\r\n      const result: GeminiResponse = await response.json();\r\n      \r\n      if (!result.candidates || result.candidates.length === 0) {\r\n        console.error('Nenhuma resposta do Gemini');\r\n        return null;\r\n      }\r\n\r\n      const text = result.candidates[0].content.parts[0].text;\r\n      console.log('Resposta do Gemini:', text);\r\n\r\n      // Extrair JSON da resposta\r\n      const jsonMatch = text.match(/\\{[\\s\\S]*?\\}/);\r\n      if (!jsonMatch) {\r\n        console.error('JSON não encontrado na resposta do Gemini');\r\n        return null;\r\n      }\r\n\r\n      let parsedData;\r\n      try {\r\n        parsedData = JSON.parse(jsonMatch[0]);\r\n      } catch (parseError) {\r\n        console.error('Erro ao fazer parse do JSON:', parseError);\r\n        return null;\r\n      }\r\n\r\n      // Validar dados essenciais\r\n      if (!parsedData.jogo || !parsedData.odd_tipster) {\r\n        console.error('Dados essenciais não encontrados');\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        id: `${chatId}_${userId}_${Date.now()}`,\r\n        chatId,\r\n        userId,\r\n        username,\r\n        message,\r\n        data: new Date(),\r\n        jogo: parsedData.jogo,\r\n        mercado: parsedData.mercado || 'Pendente',\r\n        linha_da_aposta: parsedData.linha_da_aposta || 'Não identificado',\r\n        odd_tipster: parseFloat(parsedData.odd_tipster),\r\n        placar: parsedData.placar || '0-0', // MUDANÇA: usar \"0-0\" ao invés de \"Pré\"\r\n        pegou: null,\r\n        odd_real: null,\r\n        resultado_aposta: 'Pendente'\r\n      };\r\n    } catch (error) {\r\n      console.error('Erro ao processar mensagem com Gemini:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  static async parseImageMessage(imageUrl: string, caption: string, chatId: number, userId: number, username: string): Promise<BetData | null> {\r\n    if (!this.API_KEY) {\r\n      console.error('GEMINI_API_KEY não configurada');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      console.log('🖼️ Analisando imagem com Gemini:', imageUrl);\r\n      \r\n      // Baixar a imagem e converter para base64\r\n      const imageResponse = await fetch(imageUrl);\r\n      if (!imageResponse.ok) {\r\n        console.error('Erro ao baixar imagem:', imageResponse.status);\r\n        return null;\r\n      }\r\n      \r\n      const imageBuffer = await imageResponse.arrayBuffer();\r\n      const base64Image = Buffer.from(imageBuffer).toString('base64');\r\n      \r\n      const prompt = `\r\nAnalise esta imagem de aposta esportiva e extraia as informações em formato JSON válido.\r\n\r\n${caption ? `Legenda da imagem: \"${caption}\"` : ''}\r\n\r\nVocê deve extrair:\r\n- jogo: Os times que estão jogando (formato: \"Time A vs Time B\")\r\n- mercado: Tipo de aposta (\"Goal Line\", \"Asian Handicap\", \"Resultado Final\", \"Over/Under\", etc.)\r\n- linha_da_aposta: A linha específica da aposta (ex: \"GL +0.5\", \"AH -1.0\", \"Over 2.5\", etc.)\r\n- odd_tipster: A odd fornecida pelo tipster (apenas o número, ex: \"1.85\")\r\n- placar: O placar atual do jogo se visível na imagem (ex: \"2x1\", \"1-0\", \"3x2\"). Se não houver placar ou o jogo não tiver começado, use \"0-0\"\r\n\r\nExemplos de formato para linha_da_aposta:\r\n- Goal Line: \"GL +0.5\", \"GL -1.0\", \"GL 0.0\"\r\n- Asian Handicap: \"AH +1.5\", \"AH -0.5\", \"AH 0.0\"\r\n- Over/Under: \"Over 2.5\", \"Under 1.5\"\r\n- Resultado: \"1\", \"X\", \"2\"\r\n\r\nRetorne APENAS um JSON válido no formato:\r\n{\r\n  \"jogo\": \"Time A vs Time B\",\r\n  \"mercado\": \"Goal Line\",\r\n  \"linha_da_aposta\": \"GL +0.5\",\r\n  \"odd_tipster\": \"1.85\",\r\n  \"placar\": \"2x1\" ou \"0-0\"\r\n}\r\n\r\nSe não conseguir extrair alguma informação, use null para esse campo (exceto placar que deve ser \"0-0\").`;\r\n\r\n      const response = await fetch(`${this.API_URL}?key=${this.API_KEY}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          contents: [{\r\n            parts: [\r\n              {\r\n                text: prompt\r\n              },\r\n              {\r\n                inline_data: {\r\n                  mime_type: 'image/jpeg',\r\n                  data: base64Image\r\n                }\r\n              }\r\n            ]\r\n          }],\r\n          generationConfig: {\r\n            temperature: 0.1,\r\n            maxOutputTokens: 300,\r\n          }\r\n        })\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        console.error('Erro na API do Gemini:', response.status, response.statusText, errorText);\r\n        return null;\r\n      }\r\n\r\n      const result: GeminiResponse = await response.json();\r\n      \r\n      if (!result.candidates || result.candidates.length === 0) {\r\n        console.error('Nenhuma resposta do Gemini para imagem');\r\n        return null;\r\n      }\r\n\r\n      const text = result.candidates[0].content.parts[0].text;\r\n      console.log('Resposta do Gemini para imagem:', text);\r\n\r\n      // Extrair JSON da resposta\r\n      const jsonMatch = text.match(/\\{[\\s\\S]*?\\}/);\r\n      if (!jsonMatch) {\r\n        console.error('JSON não encontrado na resposta do Gemini para imagem');\r\n        return null;\r\n      }\r\n\r\n      let parsedData;\r\n      try {\r\n        parsedData = JSON.parse(jsonMatch[0]);\r\n      } catch (parseError) {\r\n        console.error('Erro ao fazer parse do JSON da imagem:', parseError);\r\n        return null;\r\n      }\r\n      \r\n      // Criar objeto BetData\r\n      const betData: BetData = {\r\n        id: `bet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        chatId,\r\n        userId,\r\n        username,\r\n        message: caption || '[Imagem de aposta]',\r\n        data: new Date(),\r\n        jogo: parsedData.jogo || 'Não identificado',\r\n        mercado: parsedData.mercado || 'Pendente',\r\n        linha_da_aposta: parsedData.linha_da_aposta || 'Não identificado',\r\n        odd_tipster: parseFloat(parsedData.odd_tipster) || 0,\r\n        placar: parsedData.placar || '0-0', // ADICIONADO: incluir o placar\r\n        pegou: null,\r\n        odd_real: null,\r\n        resultado_aposta: 'Pendente'\r\n      };\r\n\r\n      return betData;\r\n\r\n    } catch (error) {\r\n      console.error('Erro ao analisar imagem com Gemini:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  static createConfirmationMessage(betData: BetData): string {\r\n    return `🎯 *Aposta detectada!*\\n\\n` +\r\n           `🏆 *Jogo:* ${betData.jogo}\\n` +\r\n           `📊 *Mercado:* ${betData.mercado}\\n` +\r\n           `🎲 *Linha:* ${betData.linha_da_aposta}\\n` +\r\n           `💰 *Odd Tipster:* ${betData.odd_tipster}\\n` +\r\n           `⚽ *Placar:* ${betData.placar}\\n\\n` +\r\n           `❓ Você pegou essa aposta? (Responda: sim/não)`;\r\n  }\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 634, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documentos/Trae/autosheets%20backup%202%20-%20Copia/src/lib/shared/bet-cache.ts"],"sourcesContent":["import fs from 'fs';\r\nimport path from 'path';\r\nimport { BetData } from '@/lib/telegram/parser';\r\n\r\nconst CACHE_FILE = path.join(process.cwd(), '.bet-cache.json');\r\n\r\n// CORREÇÃO: Definir interface para o cache\r\ninterface CacheData {\r\n  [key: string]: BetData;\r\n}\r\n\r\nexport class SharedBetCache {\r\n  static saveBet(key: string, betData: BetData) {\r\n    try {\r\n      let cache: CacheData = {};\r\n      if (fs.existsSync(CACHE_FILE)) {\r\n        const fileContent = fs.readFileSync(CACHE_FILE, 'utf8');\r\n        console.log(`📖 Conteúdo atual do cache: ${fileContent}`);\r\n        cache = JSON.parse(fileContent) as CacheData;\r\n      }\r\n      cache[key] = betData;\r\n      const newContent = JSON.stringify(cache, null, 2);\r\n      fs.writeFileSync(CACHE_FILE, newContent);\r\n      console.log(`💾 Aposta salva no cache: ${key}`);\r\n      console.log(`💾 Cache agora contém ${Object.keys(cache).length} apostas`);\r\n    } catch (error) {\r\n      console.error('❌ Erro ao salvar no cache:', error);\r\n    }\r\n  }\r\n\r\n  static getBet(key: string): BetData | null {\r\n    console.log(`🔍 [CACHE] Procurando chave: ${key}`);\r\n    \r\n    try {\r\n      if (!fs.existsSync(CACHE_FILE)) {\r\n        console.log('❌ [CACHE] Arquivo não existe');\r\n        return null;\r\n      }\r\n      \r\n      const fileContent = fs.readFileSync(CACHE_FILE, 'utf8');\r\n      console.log(`📖 [CACHE] Conteúdo do arquivo: ${fileContent}`);\r\n      \r\n      const cache: CacheData = JSON.parse(fileContent) as CacheData;\r\n      const keys = Object.keys(cache);\r\n      const result = cache[key] || null;\r\n      \r\n      console.log(`📋 [CACHE] Total de apostas: ${keys.length}`);\r\n      console.log(`📋 [CACHE] Chaves disponíveis: [${keys.join(', ')}]`);\r\n      console.log(`🎯 [CACHE] Chave '${key}' encontrada: ${!!result}`);\r\n      \r\n      if (result) {\r\n        console.log(`📊 [CACHE] Dados da aposta:`, {\r\n          jogo: result.jogo,\r\n          odd_tipster: result.odd_tipster,\r\n          timestamp: result.timestamp\r\n        });\r\n      } else {\r\n        console.log(`❌ [CACHE] Chave '${key}' não encontrada`);\r\n        console.log(`💡 [CACHE] Chaves similares:`);\r\n        keys.forEach(k => {\r\n          const similarity = k.includes(key.split('_')[0]) || k.includes(key.split('_')[1]);\r\n          if (similarity) {\r\n            console.log(`   - ${k} (similar)`);\r\n          }\r\n        });\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('❌ [CACHE] Erro ao ler cache:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  static removeBet(key: string) {\r\n    try {\r\n      if (!fs.existsSync(CACHE_FILE)) return;\r\n      // CORREÇÃO: Tipar explicitamente o cache\r\n      const cache: CacheData = JSON.parse(fs.readFileSync(CACHE_FILE, 'utf8')) as CacheData;\r\n      delete cache[key];\r\n      fs.writeFileSync(CACHE_FILE, JSON.stringify(cache, null, 2));\r\n      console.log(`🗑️ Aposta removida do cache: ${key}`);\r\n    } catch (error) {\r\n      console.error('Erro ao remover do cache:', error);\r\n    }\r\n  }\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 730, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documentos/Trae/autosheets%20backup%202%20-%20Copia/src/lib/telegram/gramjs-monitor.ts"],"sourcesContent":["import { TelegramClient } from 'telegram';\r\nimport { StringSession } from 'telegram/sessions';\r\nimport { NewMessage } from 'telegram/events';\r\nimport { GeminiParser } from '@/lib/gemini/parser';\r\nimport { BetData } from './parser';\r\nimport { SharedBetCache } from '@/lib/shared/bet-cache';\r\nimport input from 'input';\r\n\r\n// CORREÇÃO: Interfaces mais simples e compatíveis\r\ninterface TelegramMessage {\r\n  text?: string;\r\n  photo?: any;\r\n  senderId?: bigint;\r\n  peerId?: any;\r\n  replyTo?: {\r\n    replyToMsgId: number;\r\n  };\r\n}\r\n\r\ninterface TelegramPeer {\r\n  className: string;\r\n  channelId?: bigint;\r\n  chatId?: bigint;\r\n  userId?: bigint;\r\n  toString(): string;\r\n}\r\n\r\ninterface GramJSConfig {\r\n  apiId: number;\r\n  apiHash: string;\r\n  session: string;\r\n  allowedChatIds: string[];\r\n  yourUserId: string;\r\n  botToken: string;\r\n}\r\n\r\nclass GramJSMonitor {\r\n  private client: TelegramClient;\r\n  private allowedChatIds: Set<string>;\r\n  private yourUserId: string;\r\n  private botToken: string;\r\n  private pendingBets = new Map<string, BetData>();\r\n\r\n  constructor(config: GramJSConfig) {\r\n    const stringSession = new StringSession(config.session);\r\n    \r\n    this.client = new TelegramClient(\r\n      stringSession,\r\n      config.apiId,\r\n      config.apiHash,\r\n      {\r\n        connectionRetries: 10,\r\n        retryDelay: 5000,\r\n        timeout: 30000,\r\n        autoReconnect: true,\r\n        useWSS: true,\r\n        testServers: false,\r\n        floodSleepThreshold: 60,\r\n      }\r\n    );\r\n    \r\n    this.allowedChatIds = new Set(config.allowedChatIds);\r\n    this.yourUserId = config.yourUserId;\r\n    this.botToken = config.botToken;\r\n  }\r\n\r\n  async start() {\r\n    console.log('🚀 Iniciando GramJS Monitor...');\r\n    \r\n    const startWithRetry = async (maxRetries = 5) => {\r\n      for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n        try {\r\n          await this.client.start({\r\n            phoneNumber: async () => process.env.TELEGRAM_PHONE_NUMBER!,\r\n            password: async () => {\r\n              const password = process.env.TELEGRAM_PASSWORD;\r\n              if (password) return password;\r\n              return await input.text('Digite sua senha 2FA (se habilitada): ');\r\n            },\r\n            phoneCode: async () => {\r\n              return await input.text('Digite o código de verificação recebido no Telegram: ');\r\n            },\r\n            onError: (err: Error) => {\r\n              console.error(`❌ Erro no cliente (tentativa ${attempt}):`, err);\r\n              if (attempt < maxRetries) {\r\n                console.log(`🔄 Tentando reconectar em 10 segundos...`);\r\n              }\r\n            },\r\n          });\r\n          \r\n          console.log('✅ GramJS conectado! Configurando handlers...');\r\n          await this.setupEventHandlers();\r\n          console.log('👀 Monitorando grupos configurados...');\r\n          \r\n          this.setupConnectionMonitoring();\r\n          return;\r\n          \r\n        } catch (error) {\r\n          console.error(`❌ Falha na tentativa ${attempt}:`, error);\r\n          if (attempt < maxRetries) {\r\n            await new Promise(resolve => setTimeout(resolve, 10000));\r\n          } else {\r\n            throw error;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    \r\n    await startWithRetry();\r\n  }\r\n\r\n  private setupConnectionMonitoring() {\r\n    setInterval(async () => {\r\n      try {\r\n        if (!this.client.connected) {\r\n          console.log('🔄 Conexão perdida, tentando reconectar...');\r\n          await this.client.connect();\r\n        }\r\n      } catch (error) {\r\n        console.error('❌ Erro ao verificar conexão:', error);\r\n      }\r\n    }, 30000);\r\n  }\r\n\r\n  private async setupEventHandlers() {\r\n    this.client.addEventHandler(async (event) => {\r\n      const message = event.message as TelegramMessage;\r\n      \r\n      if (!message || !message.peerId) return;\r\n      \r\n      const chatId = this.getChatId(message.peerId as TelegramPeer);\r\n      \r\n      if (!this.allowedChatIds.has(chatId.toString()) && chatId.toString() !== this.yourUserId) {\r\n        return;\r\n      }\r\n\r\n      // Definir as variáveis que estavam faltando\r\n      const isAllowedGroup = this.allowedChatIds.has(chatId.toString());\r\n      const isPrivateFromUser = chatId.toString() === this.yourUserId;\r\n\r\n      if (isAllowedGroup) {\r\n        console.log(`👀 Nova mensagem no grupo monitorado: ${chatId}`);\r\n        \r\n        if (message.text) {\r\n          await this.processTextMessage(message, chatId);\r\n        }\r\n        \r\n        if (message.photo) {\r\n          await this.processPhotoMessage(message, chatId);\r\n        }\r\n      } else if (isPrivateFromUser) {\r\n        console.log(`💬 Mensagem privada recebida: ${message.text}`);\r\n        // Aqui você pode processar a resposta da odd\r\n        await this.processPrivateMessage(message);\r\n      }\r\n    }, new NewMessage({}));\r\n  }\r\n\r\n  // CORREÇÃO: Usar any para evitar problemas de tipagem\r\n  private async processTextMessage(message: TelegramMessage, chatId: string) {\r\n    const messageText = message.text;\r\n    const senderId = message.senderId?.toString() || '0';\r\n    \r\n    console.log(`📝 Analisando mensagem de texto: \"${messageText}\"`);\r\n\r\n    try {\r\n      if (!message.senderId) {\r\n        console.log('❌ SenderId não encontrado na mensagem');\r\n        return;\r\n      }\r\n\r\n      // CORREÇÃO: Usar any para evitar problemas de tipagem\r\n      const sender: any = await this.client.getEntity(message.senderId);\r\n      const username = sender.username || sender.firstName || 'Usuário';\r\n\r\n      const betData = await GeminiParser.parseBetMessage(\r\n        messageText || '',\r\n        parseInt(chatId),\r\n        parseInt(senderId),\r\n        username\r\n      );\r\n\r\n      if (betData) {\r\n        console.log('🎯 Aposta detectada no grupo!');\r\n        await this.sendPrivateNotification(betData);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Erro ao processar mensagem de texto:', error);\r\n    }\r\n  }\r\n\r\n  private async processPhotoMessage(message: TelegramMessage, chatId: string) {\r\n    const senderId = message.senderId?.toString() || '0';\r\n    const caption = message.text || '';\r\n\r\n    console.log('📸 Analisando imagem do grupo...');\r\n\r\n    try {\r\n      if (!message.senderId) {\r\n        console.log('❌ SenderId não encontrado na mensagem');\r\n        return;\r\n      }\r\n\r\n      // CORREÇÃO: Usar any para evitar problemas de tipagem\r\n      const sender: any = await this.client.getEntity(message.senderId);\r\n      const username = sender.username || sender.firstName || 'Usuário';\r\n      \r\n      // CORREÇÃO: Usar any para downloadMedia\r\n      const imageBuffer: any = await this.client.downloadMedia(message.photo, {\r\n        progressCallback: (progress: number) => {\r\n          console.log(`📥 Download: ${Math.round(progress * 100)}%`);\r\n        }\r\n      });\r\n      \r\n      if (imageBuffer && Buffer.isBuffer(imageBuffer)) {\r\n        const imageBase64 = imageBuffer.toString('base64');\r\n        const imageUrl = `data:image/jpeg;base64,${imageBase64}`;\r\n        \r\n        const betData = await GeminiParser.parseImageMessage(\r\n          imageUrl,\r\n          caption,\r\n          parseInt(chatId),\r\n          parseInt(senderId),\r\n          username\r\n        );\r\n\r\n        if (betData) {\r\n          console.log('🎯 Aposta detectada na imagem do grupo!');\r\n          await this.sendPrivateNotification(betData);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Erro ao processar imagem:', error);\r\n    }\r\n  }\r\n\r\n  private async sendPrivateNotification(betData: BetData) {\r\n    const message = \r\n      `🎯 **Aposta detectada no grupo!**\\n\\n` +\r\n      `⚽ **Jogo:** ${betData.jogo}\\n` +\r\n      `⚽ **Placar:** ${betData.placar || '0-0'}\\n` +\r\n      `📊 **Mercado:** ${betData.mercado}\\n` +\r\n      `📈 **Linha:** ${betData.linha_da_aposta}\\n` +\r\n      `💰 **Odd Tipster:** ${betData.odd_tipster}\\n\\n` +\r\n      `💎 **Responda esta mensagem com a odd real que você conseguiu**\\n` +\r\n      `(Digite 0 se não conseguiu pegar a aposta)`;\r\n\r\n    try {\r\n      const response = await fetch(`https://api.telegram.org/bot${this.botToken}/sendMessage`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          chat_id: this.yourUserId,\r\n          text: message,\r\n          parse_mode: 'Markdown'\r\n        })\r\n      });\r\n\r\n      const result = await response.json();\r\n      \r\n      if (result.ok) {\r\n        const botMessageId = result.result.message_id;\r\n        // CORREÇÃO: Usar yourUserId ao invés de chat.id para consistência\r\n        const betKey = `${this.yourUserId}_${botMessageId}`;\r\n        \r\n        this.pendingBets.set(betKey, betData);\r\n        SharedBetCache.saveBet(betKey, betData);\r\n        \r\n        console.log(`📤 Notificação enviada. Aguardando resposta para: ${betKey}`);\r\n        console.log(`💾 Aposta salva em ambos os caches: ${betKey}`);\r\n        console.log(`🔍 DEBUG - Chat ID: ${result.result.chat.id}, Your User ID: ${this.yourUserId}`);\r\n      } else {\r\n        console.error('❌ Erro na API do Telegram:', result);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Erro ao enviar notificação:', error);\r\n    }\r\n  }\r\n\r\n  public getPendingBet(betKey: string): BetData | undefined {\r\n    return this.pendingBets.get(betKey);\r\n  }\r\n\r\n  // NOVO: Método para debug\r\n  public getPendingBetsCount(): number {\r\n    return this.pendingBets.size;\r\n  }\r\n\r\n  // NOVO: Método para listar todas as chaves\r\n  public getPendingBetsKeys(): string[] {\r\n    return Array.from(this.pendingBets.keys());\r\n  }\r\n\r\n  public removePendingBet(betKey: string): void {\r\n    this.pendingBets.delete(betKey);\r\n    SharedBetCache.removeBet(betKey);\r\n    console.log(`🗑️ Aposta removida de ambos os caches: ${betKey}`);\r\n  }\r\n\r\n  public listPendingBets(): string[] {\r\n    return Array.from(this.pendingBets.keys());\r\n  }\r\n\r\n  // CORREÇÃO: Tipar corretamente o parâmetro peerId\r\n  private getChatId(peerId: TelegramPeer): string {\r\n    if (peerId.className === 'PeerChannel') {\r\n      return `-100${peerId.channelId}`;\r\n    } else if (peerId.className === 'PeerChat') {\r\n      return `-${peerId.chatId}`;\r\n    } else if (peerId.className === 'PeerUser') {\r\n      return peerId.userId?.toString() || '0';\r\n    }\r\n    \r\n    return peerId.toString();\r\n  }\r\n\r\n  async getSessionString(): Promise<string> {\r\n    // CORREÇÃO: Usar any para evitar problemas de tipagem\r\n    return (this.client.session.save() as any);\r\n  }\r\n\r\n  private async processPrivateMessage(message: TelegramMessage) {\r\n    // Debug: Log completo do objeto message para inspeção\r\n    console.log('🔍 DEBUG - Objeto message completo:', JSON.stringify(message, null, 2));\r\n    \r\n    // Verificar se é uma resposta a uma mensagem do bot\r\n    if (!message.replyTo) {\r\n      console.log('📝 Mensagem privada não é uma resposta');\r\n      return;\r\n    }\r\n\r\n    const repliedMessageId = message.replyTo.replyToMsgId;\r\n    const betKey = `${this.yourUserId}_${repliedMessageId}`;\r\n    \r\n    console.log(`🔍 Procurando aposta para chave: ${betKey}`);\r\n    console.log(`🔍 Chaves disponíveis no monitor:`, this.getPendingBetsKeys());\r\n    \r\n    const betData = this.getPendingBet(betKey);\r\n    if (betData && message.text) {\r\n      console.log(`💰 Processando resposta da odd: ${message.text}`);\r\n      console.log(`📋 Dados da aposta encontrada:`, betData);\r\n      \r\n      // IMPORTANTE: Delegar para o webhook para manter consistência\r\n      // O webhook tem toda a lógica de processamento e salvamento\r\n      console.log('🔄 Delegando processamento para o webhook...');\r\n      \r\n      // Manter a aposta no cache para o webhook processar\r\n      // Não remover aqui, deixar o webhook fazer isso\r\n    } else {\r\n      console.log('❌ Aposta não encontrada ou mensagem sem texto');\r\n      console.log(`❌ Texto da mensagem: ${message.text}`);\r\n      console.log(`❌ BetData encontrado: ${!!betData}`);\r\n    }\r\n  }\r\n\r\n  private async handleOddResponse(oddText: string, betKey: string, betData: BetData) {\r\n    // Implementar a mesma lógica do webhook aqui\r\n    // Ou fazer uma chamada para o webhook com os dados\r\n    console.log(`Processando odd: ${oddText} para aposta: ${betKey}`);\r\n    \r\n    // Remover da memória após processar\r\n    this.removePendingBet(betKey);\r\n  }\r\n\r\n  async stop() {\r\n    await this.client.disconnect();\r\n    console.log('🔌 GramJS Monitor desconectado');\r\n  }\r\n}\r\n\r\nexport default GramJSMonitor;"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1005, "column": 0}, "map": {"version":3,"sources":["file:///D:/Documentos/Trae/autosheets%20backup%202%20-%20Copia/src/app/api/telegram/webhook/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport GoogleSheetsService from '@/lib/sheets/service';\r\nimport { GeminiParser } from '@/lib/gemini/parser';\r\nimport { BetData } from '@/lib/telegram/parser';\r\n// NOVO: Import do GramJS monitor\r\nimport GramJSMonitor from '@/lib/telegram/gramjs-monitor';\r\nimport { SharedBetCache } from '@/lib/shared/bet-cache';\r\n\r\nconst sheetsConfig = {\r\n  spreadsheetId: process.env.GOOGLE_SHEETS_ID!,\r\n  range: 'Apostas!A:J',\r\n  credentials: {\r\n    client_email: process.env.GOOGLE_CLIENT_EMAIL!,\r\n    private_key: (process.env.GOOGLE_PRIVATE_KEY || '').replace(/\\\\n/g, '\\n'),\r\n  },\r\n};\r\n\r\nconst sheetsService = new GoogleSheetsService(sheetsConfig);\r\n\r\n// NOVO: Instância global do GramJS monitor\r\nlet gramjsMonitor: GramJSMonitor | null = null;\r\n\r\n// NOVO: Função para conectar ao monitor existente\r\nfunction setGramJSMonitor(monitor: GramJSMonitor) {\r\n  gramjsMonitor = monitor;\r\n  console.log('🔗 Monitor GramJS conectado ao webhook');\r\n}\r\n\r\nexport async function POST(request: Request) {\r\n  console.log('🔄 Webhook recebido');\r\n  \r\n  // NOVO: Verificar e conectar monitor se necessário\r\n  if (!gramjsMonitor && process.env.TELEGRAM_SESSION_STRING) {\r\n    console.log('🔗 Monitor não conectado. Tentando conectar...');\r\n    try {\r\n      const monitor = new GramJSMonitor({\r\n        apiId: parseInt(process.env.TELEGRAM_API_ID!),\r\n        apiHash: process.env.TELEGRAM_API_HASH!,\r\n        session: process.env.TELEGRAM_SESSION_STRING!,\r\n        allowedChatIds: process.env.MONITORED_CHAT_IDS!.split(','),\r\n        yourUserId: process.env.YOUR_USER_ID!,\r\n        botToken: process.env.TELEGRAM_BOT_TOKEN!\r\n      });\r\n      \r\n      setGramJSMonitor(monitor);\r\n      console.log('✅ Monitor GramJS conectado ao webhook');\r\n    } catch (error) {\r\n      console.error('❌ Erro ao conectar monitor:', error);\r\n    }\r\n  }\r\n  \r\n  console.log(`🔗 Status do monitor: ${gramjsMonitor ? 'CONECTADO' : 'DESCONECTADO'}`);\r\n  \r\n  try {\r\n    const update = await request.json();\r\n    console.log('📦 Update recebido:', JSON.stringify(update, null, 2));\r\n    \r\n    // NOVO: Log detalhado\r\n    console.log('🔍 Tipo de update:', {\r\n      hasMessage: !!update.message,\r\n      hasText: !!update.message?.text,\r\n      hasReplyTo: !!update.message?.reply_to_message,\r\n      chatId: update.message?.chat?.id,\r\n      userId: update.message?.from?.id,\r\n      messageText: update.message?.text\r\n    });\r\n    \r\n    const message = update.message;\r\n     \r\n    // Processar apenas respostas às notificações do bot\r\n    if (update.message && update.message.text) {\r\n      const chatId = update.message.chat.id;\r\n      const userId = update.message.from.id;\r\n      const messageText = update.message.text;\r\n      \r\n      console.log(`📨 Mensagem de ${userId}: \"${messageText}\"`);\r\n      \r\n      // NOVO: Verificar se é uma resposta\r\n        if (message.reply_to_message) {\r\n          const repliedMessageId = message.reply_to_message.message_id;\r\n          // CORREÇÃO: Usar o ID da mensagem à qual está respondendo\r\n          const betKey = `${userId}_${repliedMessageId}`;\r\n          \r\n          console.log('🔍 Debug da chave:');\r\n          console.log('- chatId:', chatId);\r\n          console.log('- userId:', userId);\r\n          console.log('- repliedMessageId:', repliedMessageId);\r\n          console.log('- betKey gerada:', betKey);\r\n          \r\n          // ADICIONAR: Log das chaves disponíveis\r\n          console.log('- Chaves no cache compartilhado:', Object.keys(require('fs').existsSync('.bet-cache.json') ? JSON.parse(require('fs').readFileSync('.bet-cache.json', 'utf8')) : {}));\r\n          \r\n          if (gramjsMonitor) {\r\n            console.log('- Chaves disponíveis no monitor:', gramjsMonitor.getPendingBetsKeys());\r\n          }\r\n          \r\n          console.log(`🔍 Procurando aposta com chave: ${betKey}`);\r\n          console.log(`🔍 Monitor disponível: ${!!gramjsMonitor}`);\r\n        \r\n        let betData = null;\r\n        \r\n        // Verificar primeiro no GramJS monitor (se disponível)\r\n        if (gramjsMonitor) {\r\n          betData = gramjsMonitor.getPendingBet(betKey);\r\n          console.log(`📋 Aposta encontrada no GramJS monitor: ${!!betData}`);\r\n          if (betData) {\r\n            console.log(`📋 Dados da aposta no monitor:`, betData);\r\n          }\r\n        } else {\r\n          console.log('⚠️ GramJS monitor não está disponível!');\r\n        }\r\n        \r\n        // Se não encontrou no monitor, verificar no cache compartilhado\r\n        if (!betData) {\r\n          console.log(`🔍 Verificando cache compartilhado para: ${betKey}`);\r\n          betData = SharedBetCache.getBet(betKey);\r\n          console.log(`📋 Aposta encontrada no cache compartilhado: ${!!betData}`);\r\n          if (betData) {\r\n            console.log(`📋 Dados da aposta no cache:`, betData);\r\n          }\r\n        }\r\n        \r\n        // NOVO: Log do estado dos caches\r\n        console.log('📊 Estado dos caches:');\r\n        console.log('- Monitor pendingBets size:', gramjsMonitor ? gramjsMonitor.getPendingBetsCount() : 'N/A');\r\n        console.log('- Cache file exists:', require('fs').existsSync('.bet-cache.json'));\r\n        \r\n        if (betData) {\r\n          console.log('💰 Processando resposta à notificação...');\r\n          await handleOddReply(update, betKey, betData);\r\n          \r\n          // Remover de ambos os caches\r\n          if (gramjsMonitor) {\r\n            gramjsMonitor.removePendingBet(betKey);\r\n          }\r\n          SharedBetCache.removeBet(betKey);\r\n          \r\n          return NextResponse.json({ ok: true, processed: true });\r\n        } else {\r\n          console.log('❌ Nenhuma aposta pendente encontrada para esta resposta');\r\n          console.log('❌ Chave procurada:', betKey);\r\n          console.log('❌ Isso pode indicar que:');\r\n          console.log('   1. A aposta expirou ou foi removida');\r\n          console.log('   2. O monitor não está funcionando');\r\n          console.log('   3. Há um problema na geração da chave');\r\n        }\r\n      } else {\r\n        console.log('ℹ️ Mensagem não é uma resposta (não tem reply_to_message)');\r\n      }\r\n    } else {\r\n      console.log('ℹ️ Update não contém mensagem de texto');\r\n    }\r\n    \r\n    return NextResponse.json({ ok: true, processed: false });\r\n  } catch (error) {\r\n    console.error('❌ Erro no webhook:', error);\r\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\r\n  }\r\n}\r\n\r\n// Função para processar resposta da odd (corrigir tipagem)\r\nasync function handleOddReply(update: any, betKey: string, betData: BetData) {\r\n  // Adicionar verificações de segurança\r\n  if (!update?.message?.chat?.id || !update?.message?.text) {\r\n    console.error('❌ Update inválido recebido:', update);\r\n    return;\r\n  }\r\n  \r\n  const chatId = update.message.chat.id;\r\n  const messageText = update.message.text.trim();\r\n  \r\n  console.log(`📊 Processando resposta da ODD: \"${messageText}\" para chave: ${betKey}`);\r\n  \r\n  const oddReal = parseFloat(messageText.replace(',', '.'));\r\n  console.log(`📊 Odd recebida: ${messageText} -> ${oddReal}`);\r\n  \r\n  if (oddReal === 0) {\r\n    // Aposta não foi pega\r\n    betData.pegou = false;\r\n    betData.odd_real = null;\r\n    \r\n    console.log('💾 Salvando aposta como NÃO PEGA no Google Sheets:', betData);\r\n    const success = await sheetsService.addBetData(betData);\r\n    \r\n    if (success) {\r\n      await sendTelegramMessage(\r\n        chatId,\r\n        `❌ **Aposta não realizada**\\n\\n` +\r\n        `⚽ **Jogo:** ${betData.jogo}\\n` +\r\n        `⚽ **Placar:** ${betData.placar || '0-0'}\\n` +\r\n        `📊 **Mercado:** ${betData.mercado}\\n` +\r\n        `📈 **Linha:** ${betData.linha_da_aposta}\\n` +\r\n        `💰 **Odd Tipster:** ${betData.odd_tipster}\\n\\n` +\r\n        `✅ Registrado que a aposta não foi pega.`\r\n      );\r\n      console.log('✅ Aposta marcada como não realizada e salva com sucesso');\r\n    } else {\r\n      console.error('❌ Erro ao salvar aposta não realizada');\r\n      await sendTelegramMessage(\r\n        chatId,\r\n        `❌ **Erro ao salvar**\\n\\nHouve erro ao salvar no Google Sheets. Verifique os logs.`\r\n      );\r\n    }\r\n  } else if (!isNaN(oddReal) && oddReal > 0) {\r\n    // Aposta foi pega com odd válida\r\n    betData.pegou = true;\r\n    betData.odd_real = oddReal;\r\n    \r\n    console.log('💾 Salvando aposta PEGA no Google Sheets:', betData);\r\n    \r\n    const success = await sheetsService.addBetData(betData);\r\n    \r\n    if (success) {\r\n      await sendTelegramMessage(\r\n        chatId,\r\n        `✅ **Aposta registrada com sucesso!**\\n\\n` +\r\n        `⚽ **Jogo:** ${betData.jogo}\\n` +\r\n        `⚽ **Placar:** ${betData.placar || '0-0'}\\n` +\r\n        `📊 **Mercado:** ${betData.mercado}\\n` +\r\n        `📈 **Linha:** ${betData.linha_da_aposta}\\n` +\r\n        `💰 **Odd Tipster:** ${betData.odd_tipster}\\n` +\r\n        `💎 **Odd Real:** ${betData.odd_real}\\n` +\r\n        `📊 **Status:** ${betData.resultado_aposta}`\r\n      );\r\n      \r\n      console.log('✅ Aposta salva com sucesso no Google Sheets');\r\n    } else {\r\n      console.error('❌ Erro ao salvar aposta no Google Sheets');\r\n      await sendTelegramMessage(\r\n        chatId,\r\n        `❌ **Erro ao salvar**\\n\\nHouve erro ao salvar no Google Sheets. Verifique os logs.`\r\n      );\r\n    }\r\n  } else {\r\n    // Odd inválida\r\n    console.log(`❌ Odd inválida recebida: ${messageText}`);\r\n    await sendTelegramMessage(\r\n      chatId,\r\n      `❌ **Odd inválida**\\n\\nPor favor, responda com um número válido ou 0 para \\\"não peguei\\\".\\n\\nExemplos: 1.85, 2.50, 0`\r\n    );\r\n    return; // Não remove do cache\r\n  }\r\n}\r\n\r\nasync function sendTelegramMessage(chatId: number, text: string) {\r\n  const botToken = process.env.TELEGRAM_BOT_TOKEN!;\r\n  \r\n  try {\r\n    console.log(`Enviando mensagem para chat ${chatId}:`, text);\r\n    \r\n    const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({\r\n        chat_id: chatId,\r\n        text: text,\r\n        parse_mode: 'Markdown'\r\n      })\r\n    });\r\n    \r\n    const result = await response.json();\r\n    \r\n    if (!response.ok) {\r\n      console.error('Erro na API do Telegram:', result);\r\n    } else {\r\n      console.log('Mensagem enviada com sucesso');\r\n    }\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    console.error('Erro ao enviar mensagem:', error);\r\n  }\r\n}\r\n\r\nasync function getTelegramFileUrl(fileId: string): Promise<string> {\r\n  const response = await fetch(\r\n    `https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/getFile?file_id=${fileId}`\r\n  );\r\n  const data = await response.json();\r\n  return `https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${data.result.file_path}`;\r\n}"],"names":[],"mappings":"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","debugId":null}}]
}