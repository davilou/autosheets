module.exports = {

"[project]/.next-internal/server/app/api/telegram/webhook/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/http2 [external] (http2, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[project]/src/lib/sheets/service.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/googleapis/build/src/index.js [app-route] (ecmascript)");
;
class GoogleSheetsService {
    sheets;
    auth;
    config;
    constructor(config){
        this.config = config;
        this.initializeAuth();
    }
    async initializeAuth() {
        try {
            this.auth = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].auth.GoogleAuth({
                credentials: this.config.credentials,
                scopes: [
                    'https://www.googleapis.com/auth/spreadsheets'
                ]
            });
            this.sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
                version: 'v4',
                auth: this.auth
            });
        } catch (error) {
            console.error('Erro ao inicializar autenticaÃ§Ã£o Google Sheets:', error);
            throw error;
        }
    }
    async addBetData(betData) {
        try {
            console.log('Dados recebidos para salvar:', betData);
            const values = this.formatBetDataForSheets(betData);
            console.log('Valores formatados:', values);
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: this.config.range,
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values: [
                        values
                    ]
                }
            };
            console.log('Enviando para Google Sheets:', request);
            const response = await this.sheets.spreadsheets.values.append(request);
            console.log('Resposta do Google Sheets:', response.status, response.statusText);
            if (response.status === 200) {
                console.log('âœ… Dados adicionados com sucesso ao Google Sheets');
                return true;
            }
            console.error('âŒ Falha ao adicionar dados - Status:', response.status);
            return false;
        } catch (error) {
            console.error('âŒ Erro ao adicionar dados ao Google Sheets:', error);
            if (error instanceof Error && error.response) {
                console.error('Detalhes do erro:', error.response.data);
            }
            return false;
        }
    }
    async addMultipleBetData(betDataArray) {
        if (betDataArray.length === 0) return 0;
        try {
            const values = betDataArray.map((bet)=>this.formatBetDataForSheets(bet));
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: this.config.range,
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values
                }
            };
            const response = await this.sheets.spreadsheets.values.append(request);
            if (response.status === 200) {
                console.log(`${betDataArray.length} registros adicionados com sucesso`);
                return betDataArray.length;
            }
            return 0;
        } catch (error) {
            console.error('Erro ao adicionar mÃºltiplos dados:', error);
            return 0;
        }
    }
    formatBetDataForSheets(betData) {
        // FormataÃ§Ã£o corrigida para a estrutura real da planilha
        return [
            betData.data instanceof Date ? betData.data.toLocaleString('pt-BR') : new Date(betData.data).toLocaleString('pt-BR'),
            betData.jogo,
            '',
            betData.linha_da_aposta,
            betData.mercado,
            typeof betData.odd_tipster === 'number' ? betData.odd_tipster.toString() : betData.odd_tipster,
            betData.pegou === true ? 'SIM' : betData.pegou === false ? 'NÃƒO' : 'PENDENTE',
            betData.odd_real ? betData.odd_real.toString() : '',
            '',
            betData.resultado_aposta || 'Pendente'
        ];
    }
    async createHeaderRow() {
        try {
            const headers = [
                'Data',
                'Jogo',
                'Placar',
                'Linha_da_Aposta',
                'Mercado',
                'Odd_Tipster',
                'Pegou',
                'Odd_Real',
                'Resultado_Jogo',
                'Resultado_Aposta' // J
            ];
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: 'A1:J1',
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values: [
                        headers
                    ]
                }
            };
            const response = await this.sheets.spreadsheets.values.update(request);
            console.log('CabeÃ§alho criado:', response.status === 200 ? 'Sucesso' : 'Falha');
            return response.status === 200;
        } catch (error) {
            console.error('Erro ao criar cabeÃ§alho:', error);
            return false;
        }
    }
    async getSheetData(range) {
        try {
            const response = await this.sheets.spreadsheets.values.get({
                spreadsheetId: this.config.spreadsheetId,
                range: range || this.config.range
            });
            return response.data.values || [];
        } catch (error) {
            console.error('Erro ao buscar dados da planilha:', error);
            return [];
        }
    }
    // MÃ©todo para testar a conexÃ£o
    async testConnection() {
        try {
            const response = await this.sheets.spreadsheets.get({
                spreadsheetId: this.config.spreadsheetId
            });
            console.log('âœ… ConexÃ£o com Google Sheets OK:', response.data.properties.title);
            return true;
        } catch (error) {
            console.error('âŒ Erro na conexÃ£o com Google Sheets:', error);
            return false;
        }
    }
}
const __TURBOPACK__default__export__ = GoogleSheetsService;
}),
"[project]/src/lib/ai/gemini-parser.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GeminiParser": ()=>GeminiParser
});
class GeminiParser {
    static API_KEY = process.env.GEMINI_API_KEY;
    // Atualizar para o modelo correto
    static API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';
    static async parseBetMessage(message, chatId, userId, username) {
        if (!this.API_KEY) {
            console.error('GEMINI_API_KEY nÃ£o configurada');
            return null;
        }
        try {
            const prompt = `
Analise esta mensagem de aposta do Telegram e extraia as informaÃ§Ãµes em formato JSON vÃ¡lido.

Mensagem: "${message}"

VocÃª deve extrair:
- jogo: Os times que estÃ£o jogando (formato: "Time A vs Time B")
- mercado: Tipo de aposta ("Goal Line", "Asian Handicap", "Resultado Final", "Over/Under", etc.)
- linha_da_aposta: A linha especÃ­fica da aposta (ex: "GL +0.5", "AH -1.0", "Over 2.5", etc.)
- odd_tipster: A odd fornecida pelo tipster (apenas o nÃºmero, ex: "1.85")

Exemplos de formato para linha_da_aposta:
- Goal Line: "GL +0.5", "GL -1.0", "GL 0.0"
- Asian Handicap: "AH +1.5", "AH -0.5", "AH 0.0"
- Over/Under: "Over 2.5", "Under 1.5"
- Resultado: "1", "X", "2"

Retorne APENAS um JSON vÃ¡lido no formato:
{
  "jogo": "Time A vs Time B",
  "mercado": "Goal Line",
  "linha_da_aposta": "GL +0.5",
  "odd_tipster": "1.85"
}

Se nÃ£o conseguir extrair alguma informaÃ§Ã£o, use null para esse campo.`;
            const response = await fetch(`${this.API_URL}?key=${this.API_KEY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [
                        {
                            parts: [
                                {
                                    text: prompt
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: 0.1,
                        maxOutputTokens: 200
                    }
                })
            });
            if (!response.ok) {
                console.error('Erro na API do Gemini:', response.status, response.statusText);
                return null;
            }
            const result = await response.json();
            if (!result.candidates || result.candidates.length === 0) {
                console.error('Nenhuma resposta do Gemini');
                return null;
            }
            const text = result.candidates[0].content.parts[0].text;
            console.log('Resposta do Gemini:', text);
            // Extrair JSON da resposta
            const jsonMatch = text.match(/\{[^}]+\}/);
            if (!jsonMatch) {
                console.error('JSON nÃ£o encontrado na resposta do Gemini');
                return null;
            }
            const parsedData = JSON.parse(jsonMatch[0]);
            // Criar objeto BetData
            const betData = {
                id: `bet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                chatId,
                userId,
                username,
                message,
                data: new Date(),
                jogo: parsedData.jogo || 'NÃ£o identificado',
                mercado: parsedData.mercado || 'Pendente',
                linha_da_aposta: parsedData.linha_da_aposta || 'NÃ£o identificado',
                odd_tipster: parseFloat(parsedData.odd_tipster) || 0,
                pegou: null,
                odd_real: null,
                resultado_aposta: 'Pendente'
            };
            return betData;
        } catch (error) {
            console.error('Erro ao analisar mensagem com Gemini:', error);
            return null;
        }
    }
    static createConfirmationMessage(betData) {
        return `ğŸ¯ *Aposta detectada!*\n\n` + `ğŸ† *Jogo:* ${betData.jogo}\n` + `ğŸ“Š *Mercado:* ${betData.mercado}\n` + `ğŸ² *Linha:* ${betData.linha_da_aposta}\n` + `ğŸ’° *Odd Tipster:* ${betData.odd_tipster}\n\n` + `â“ VocÃª pegou essa aposta? (Responda: sim/nÃ£o)`;
    }
}
}),
"[project]/src/app/api/telegram/webhook/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GET": ()=>GET,
    "POST": ()=>POST
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sheets$2f$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/sheets/service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$ai$2f$gemini$2d$parser$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/ai/gemini-parser.ts [app-route] (ecmascript)");
;
;
;
const sheetsConfig = {
    spreadsheetId: process.env.GOOGLE_SHEETS_ID,
    range: 'Apostas!A:J',
    credentials: {
        client_email: process.env.GOOGLE_CLIENT_EMAIL,
        private_key: (process.env.GOOGLE_PRIVATE_KEY || '').replace(/\\n/g, '\n')
    }
};
const sheetsService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sheets$2f$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](sheetsConfig);
// Cache temporÃ¡rio para aguardar respostas dos usuÃ¡rios
const pendingConfirmations = new Map();
async function GET() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        status: 'Webhook ativo! ğŸ¤–',
        timestamp: new Date().toISOString(),
        message: 'Este endpoint estÃ¡ funcionando corretamente para receber webhooks do Telegram.'
    });
}
async function POST(request) {
    try {
        const update = await request.json();
        console.log('Update recebido:', JSON.stringify(update, null, 2));
        if (update.message && update.message.text) {
            const chatId = update.message.chat.id;
            const userId = update.message.from.id;
            const username = update.message.from.username;
            const messageText = update.message.text;
            const messageLower = messageText.toLowerCase().trim();
            console.log(`Mensagem de ${username} (${userId}): "${messageText}"`);
            const pendingKey = `${chatId}_${userId}`;
            const oddKey = `${pendingKey}_odd`;
            // 1. Verificar se estÃ¡ aguardando odd real
            if (pendingConfirmations.has(oddKey)) {
                console.log('Processando odd real...');
                await handleOddResponse(update, oddKey);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: true
                });
            }
            // 2. Verificar se Ã© resposta SIM/NÃƒO para confirmaÃ§Ã£o de aposta
            if (pendingConfirmations.has(pendingKey) && (messageLower === 'sim' || messageLower === 'nÃ£o' || messageLower === 'nao')) {
                console.log('Processando confirmaÃ§Ã£o de aposta...');
                await handleBetConfirmation(update, pendingKey);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: true
                });
            }
            // 3. Processar nova mensagem de aposta com IA (MUDANÃ‡A AQUI!)
            console.log('ğŸ¤– Analisando mensagem com Gemini AI...');
            const betData = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$ai$2f$gemini$2d$parser$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GeminiParser"].parseBetMessage(messageText, chatId, userId, username);
            if (betData) {
                console.log('âœ… Nova aposta detectada pela IA:', betData);
                // Salvar temporariamente e solicitar confirmaÃ§Ã£o
                pendingConfirmations.set(pendingKey, betData);
                // Enviar mensagem de confirmaÃ§Ã£o
                await sendTelegramMessage(chatId, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$ai$2f$gemini$2d$parser$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GeminiParser"].createConfirmationMessage(betData));
                console.log('ğŸ“¤ Mensagem de confirmaÃ§Ã£o enviada');
            } else {
                console.log('âŒ Mensagem nÃ£o reconhecida como aposta vÃ¡lida pela IA');
            }
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true
        });
    } catch (error) {
        console.error('Erro no webhook do Telegram:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: false
        }, {
            status: 500
        });
    }
}
async function handleBetConfirmation(update, pendingKey) {
    const chatId = update.message.chat.id;
    const userId = update.message.from.id;
    const messageLower = update.message.text.toLowerCase().trim();
    const betData = pendingConfirmations.get(pendingKey);
    if (!betData) {
        console.log('Dados da aposta nÃ£o encontrados no cache');
        return;
    }
    console.log(`ConfirmaÃ§Ã£o recebida: ${messageLower}`);
    if (messageLower === 'sim') {
        betData.pegou = true;
        // Mover para aguardar odd real
        const oddKey = `${pendingKey}_odd`;
        pendingConfirmations.set(oddKey, betData);
        pendingConfirmations.delete(pendingKey);
        // Perguntar a odd real
        await sendTelegramMessage(chatId, `âœ… **Confirmado!**\n\nğŸ’° **Qual foi a odd real que vocÃª conseguiu?**\n\nDigite apenas o nÃºmero (ex: 1.85)`);
        console.log('Pergunta sobre odd real enviada');
    } else {
        betData.pegou = false;
        betData.odd_real = null;
        // Salvar no Google Sheets
        const success = await sheetsService.addBetData(betData);
        await sendTelegramMessage(chatId, `âŒ **Aposta nÃ£o realizada**\n\nDados salvos no sistema.`);
        pendingConfirmations.delete(pendingKey);
        console.log(`Aposta nÃ£o realizada salva. Sucesso: ${success}`);
    }
}
async function handleOddResponse(update, oddKey) {
    const chatId = update.message.chat.id;
    const messageText = update.message.text;
    const betData = pendingConfirmations.get(oddKey);
    if (!betData) {
        console.log('âŒ Dados da aposta nÃ£o encontrados para odd real');
        return;
    }
    const oddReal = parseFloat(messageText.replace(',', '.'));
    console.log(`ğŸ“Š Odd real recebida: ${messageText} -> ${oddReal}`);
    if (!isNaN(oddReal) && oddReal > 0) {
        betData.odd_real = oddReal;
        console.log('ğŸ’¾ Tentando salvar no Google Sheets:', betData);
        // Testar conexÃ£o primeiro
        const connectionOk = await sheetsService.testConnection();
        if (!connectionOk) {
            console.error('âŒ Falha na conexÃ£o com Google Sheets');
            await sendTelegramMessage(chatId, 'âŒ **Erro de conexÃ£o**\n\nNÃ£o foi possÃ­vel conectar ao Google Sheets.');
            return;
        }
        // Salvar no Google Sheets
        const success = await sheetsService.addBetData(betData);
        if (success) {
            await sendTelegramMessage(chatId, `âœ… **Aposta registrada com sucesso!**\n\n` + `âš½ **Jogo:** ${betData.jogo}\n` + `ğŸ“Š **Mercado:** ${betData.mercado}\n` + `ğŸ“ˆ **Linha:** ${betData.linha_da_aposta}\n` + `ğŸ’° **Odd Tipster:** ${betData.odd_tipster}\n` + `ğŸ’ **Odd Real:** ${betData.odd_real}\n` + `ğŸ“Š **Status:** ${betData.resultado_aposta}`);
            console.log('âœ… Aposta salva com sucesso no Google Sheets');
        } else {
            await sendTelegramMessage(chatId, `âŒ **Erro ao salvar**\n\nA aposta foi processada mas houve erro ao salvar no Google Sheets. Verifique os logs.`);
            console.error('âŒ Falha ao salvar no Google Sheets');
        }
        pendingConfirmations.delete(oddKey);
    } else {
        await sendTelegramMessage(chatId, `âŒ **Odd invÃ¡lida**\n\nPor favor, digite um nÃºmero vÃ¡lido (ex: 1.85)`);
        console.log('âŒ Odd invÃ¡lida, aguardando nova resposta');
    }
}
async function sendTelegramMessage(chatId, text) {
    const botToken = process.env.TELEGRAM_BOT_TOKEN;
    try {
        console.log(`Enviando mensagem para chat ${chatId}:`, text);
        const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                chat_id: chatId,
                text: text,
                parse_mode: 'Markdown'
            })
        });
        const result = await response.json();
        if (!response.ok) {
            console.error('Erro na API do Telegram:', result);
        } else {
            console.log('Mensagem enviada com sucesso');
        }
        return result;
    } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
    }
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__3c394961._.js.map