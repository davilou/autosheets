module.exports = {

"[project]/.next-internal/server/app/api/telegram/webhook/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/http2 [external] (http2, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[project]/src/lib/sheets/service.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/googleapis/build/src/index.js [app-route] (ecmascript)");
;
class GoogleSheetsService {
    sheets;
    auth;
    config;
    constructor(config){
        this.config = config;
        this.initializeAuth();
    }
    async initializeAuth() {
        try {
            this.auth = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].auth.GoogleAuth({
                credentials: this.config.credentials,
                scopes: [
                    'https://www.googleapis.com/auth/spreadsheets'
                ]
            });
            this.sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
                version: 'v4',
                auth: this.auth
            });
        } catch (error) {
            console.error('Erro ao inicializar autenticação Google Sheets:', error);
            throw error;
        }
    }
    async addBetData(betData) {
        try {
            console.log('Dados recebidos para salvar:', betData);
            const values = this.formatBetDataForSheets(betData);
            console.log('Valores formatados:', values);
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: this.config.range,
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values: [
                        values
                    ]
                }
            };
            console.log('Enviando para Google Sheets:', request);
            const response = await this.sheets.spreadsheets.values.append(request);
            console.log('Resposta do Google Sheets:', response.status, response.statusText);
            if (response.status === 200) {
                console.log('✅ Dados adicionados com sucesso ao Google Sheets');
                return true;
            }
            console.error('❌ Falha ao adicionar dados - Status:', response.status);
            return false;
        } catch (error) {
            console.error('❌ Erro ao adicionar dados ao Google Sheets:', error);
            if (error instanceof Error && error.response) {
                console.error('Detalhes do erro:', error.response.data);
            }
            return false;
        }
    }
    async addMultipleBetData(betDataArray) {
        if (betDataArray.length === 0) return 0;
        try {
            const values = betDataArray.map((bet)=>this.formatBetDataForSheets(bet));
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: this.config.range,
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values
                }
            };
            const response = await this.sheets.spreadsheets.values.append(request);
            if (response.status === 200) {
                console.log(`${betDataArray.length} registros adicionados com sucesso`);
                return betDataArray.length;
            }
            return 0;
        } catch (error) {
            console.error('Erro ao adicionar múltiplos dados:', error);
            return 0;
        }
    }
    formatBetDataForSheets(betData) {
        // Formatação corrigida para a estrutura real da planilha
        return [
            betData.data instanceof Date ? betData.data.toLocaleString('pt-BR') : new Date(betData.data).toLocaleString('pt-BR'),
            betData.jogo,
            betData.placar || '0-0',
            betData.linha_da_aposta,
            betData.mercado,
            typeof betData.odd_tipster === 'number' ? betData.odd_tipster.toString() : betData.odd_tipster,
            betData.pegou === true ? 'SIM' : betData.pegou === false ? 'NÃO' : 'PENDENTE',
            betData.odd_real ? betData.odd_real.toString() : '',
            '',
            betData.resultado_aposta || 'Pendente'
        ];
    }
    async createHeaderRow() {
        try {
            const headers = [
                'Data',
                'Jogo',
                'Placar',
                'Linha_da_Aposta',
                'Mercado',
                'Odd_Tipster',
                'Pegou',
                'Odd_Real',
                'Resultado_Jogo',
                'Resultado_Aposta' // J
            ];
            const request = {
                spreadsheetId: this.config.spreadsheetId,
                range: 'A1:J1',
                valueInputOption: 'USER_ENTERED',
                resource: {
                    values: [
                        headers
                    ]
                }
            };
            const response = await this.sheets.spreadsheets.values.update(request);
            console.log('Cabeçalho criado:', response.status === 200 ? 'Sucesso' : 'Falha');
            return response.status === 200;
        } catch (error) {
            console.error('Erro ao criar cabeçalho:', error);
            return false;
        }
    }
    async getSheetData(range) {
        try {
            const response = await this.sheets.spreadsheets.values.get({
                spreadsheetId: this.config.spreadsheetId,
                range: range || this.config.range
            });
            return response.data.values || [];
        } catch (error) {
            console.error('Erro ao buscar dados da planilha:', error);
            return [];
        }
    }
    // Método para testar a conexão
    async testConnection() {
        try {
            const response = await this.sheets.spreadsheets.get({
                spreadsheetId: this.config.spreadsheetId
            });
            console.log('✅ Conexão com Google Sheets OK:', response.data.properties.title);
            return true;
        } catch (error) {
            console.error('❌ Erro na conexão com Google Sheets:', error);
            return false;
        }
    }
}
const __TURBOPACK__default__export__ = GoogleSheetsService;
}),
"[project]/src/lib/shared/bet-cache.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "SharedBetCache": ()=>SharedBetCache
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
const CACHE_FILE = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), '.bet-cache.json');
class SharedBetCache {
    static saveBet(key, betData) {
        try {
            // CORREÇÃO: Tipar explicitamente o cache
            let cache = {};
            if (__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(CACHE_FILE)) {
                cache = JSON.parse(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(CACHE_FILE, 'utf8'));
            }
            cache[key] = betData;
            __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].writeFileSync(CACHE_FILE, JSON.stringify(cache, null, 2));
            console.log(`💾 Aposta salva no cache: ${key}`);
        } catch (error) {
            console.error('Erro ao salvar no cache:', error);
        }
    }
    static getBet(key) {
        try {
            if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(CACHE_FILE)) return null;
            // CORREÇÃO: Tipar explicitamente o cache
            const cache = JSON.parse(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(CACHE_FILE, 'utf8'));
            return cache[key] || null;
        } catch (error) {
            console.error('Erro ao ler cache:', error);
            return null;
        }
    }
    static removeBet(key) {
        try {
            if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(CACHE_FILE)) return;
            // CORREÇÃO: Tipar explicitamente o cache
            const cache = JSON.parse(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(CACHE_FILE, 'utf8'));
            delete cache[key];
            __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].writeFileSync(CACHE_FILE, JSON.stringify(cache, null, 2));
            console.log(`🗑️ Aposta removida do cache: ${key}`);
        } catch (error) {
            console.error('Erro ao remover do cache:', error);
        }
    }
}
}),
"[project]/src/app/api/telegram/webhook/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "POST": ()=>POST,
    "setGramJSMonitor": ()=>setGramJSMonitor
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sheets$2f$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/sheets/service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$shared$2f$bet$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/shared/bet-cache.ts [app-route] (ecmascript)");
;
;
;
const sheetsConfig = {
    spreadsheetId: process.env.GOOGLE_SHEETS_ID,
    range: 'Apostas!A:J',
    credentials: {
        client_email: process.env.GOOGLE_CLIENT_EMAIL,
        private_key: (process.env.GOOGLE_PRIVATE_KEY || '').replace(/\\n/g, '\n')
    }
};
const sheetsService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sheets$2f$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](sheetsConfig);
// NOVO: Instância global do GramJS monitor
let gramjsMonitor = null;
function setGramJSMonitor(monitor) {
    gramjsMonitor = monitor;
    console.log('🔗 Monitor GramJS conectado ao webhook');
}
async function POST(request) {
    console.log('🔄 Webhook recebido');
    try {
        const update = await request.json();
        console.log('📦 Update recebido:', JSON.stringify(update, null, 2));
        // NOVO: Log detalhado
        console.log('🔍 Tipo de update:', {
            hasMessage: !!update.message,
            hasText: !!update.message?.text,
            hasReplyTo: !!update.message?.reply_to_message,
            chatId: update.message?.chat?.id,
            userId: update.message?.from?.id,
            messageText: update.message?.text
        });
        const message = update.message;
        // Processar apenas respostas às notificações do bot
        if (update.message && update.message.text) {
            const chatId = update.message.chat.id;
            const userId = update.message.from.id;
            const messageText = update.message.text;
            console.log(`📨 Mensagem de ${userId}: "${messageText}"`);
            // Verificar se é uma resposta a uma notificação do bot
            // ...
            // Na função POST, substitua a verificação do monitor:
            if (message.reply_to_message) {
                const repliedMessageId = message.reply_to_message.message_id;
                const betKey = `${chatId}_${repliedMessageId}`;
                console.log(`🔍 Procurando aposta com chave: ${betKey}`);
                let betData = null;
                // Verificar primeiro no GramJS monitor (se disponível)
                if (gramjsMonitor) {
                    betData = gramjsMonitor.getPendingBet(betKey);
                    console.log(`📋 Aposta encontrada no GramJS monitor: ${!!betData}`);
                }
                // Se não encontrou no monitor, verificar no cache compartilhado
                if (!betData) {
                    betData = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$shared$2f$bet$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SharedBetCache"].getBet(betKey);
                    console.log(`📋 Aposta encontrada no cache compartilhado: ${!!betData}`);
                }
                if (betData) {
                    console.log('💰 Processando resposta à notificação...');
                    await handleOddReply(update, betKey, betData);
                    // Remover de ambos os caches
                    if (gramjsMonitor) {
                        gramjsMonitor.removePendingBet(betKey);
                    }
                    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$shared$2f$bet$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SharedBetCache"].removeBet(betKey);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        ok: true,
                        processed: true
                    });
                }
            }
            console.log('ℹ️ Mensagem não relacionada a apostas pendentes');
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true,
            processed: false
        });
    } catch (error) {
        console.error('❌ Erro no webhook:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Internal server error'
        }, {
            status: 500
        });
    }
}
// Função para processar resposta da odd (mantém a mesma lógica)
async function handleOddReply(update, betKey, betData) {
    const chatId = update.message.chat.id;
    const messageText = update.message.text.trim();
    const oddReal = parseFloat(messageText.replace(',', '.'));
    console.log(`📊 Odd recebida: ${messageText} -> ${oddReal}`);
    if (oddReal === 0) {
        // Aposta não foi pega
        betData.pegou = false;
        betData.odd_real = null;
        const success = await sheetsService.addBetData(betData);
        await sendTelegramMessage(chatId, `❌ **Aposta não realizada**\n\n` + `⚽ **Jogo:** ${betData.jogo}\n` + `⚽ **Placar:** ${betData.placar || '0-0'}\n` + `📊 **Mercado:** ${betData.mercado}\n` + `📈 **Linha:** ${betData.linha_da_aposta}\n` + `💰 **Odd Tipster:** ${betData.odd_tipster}\n\n` + `Registrado que a aposta não foi pega.`);
        console.log('❌ Aposta marcada como não realizada');
    } else if (!isNaN(oddReal) && oddReal > 0) {
        // Aposta foi pega com odd válida
        betData.pegou = true;
        betData.odd_real = oddReal;
        console.log('💾 Salvando aposta no Google Sheets:', betData);
        const success = await sheetsService.addBetData(betData);
        if (success) {
            await sendTelegramMessage(chatId, `✅ **Aposta registrada com sucesso!**\n\n` + `⚽ **Jogo:** ${betData.jogo}\n` + `⚽ **Placar:** ${betData.placar || '0-0'}\n` + `📊 **Mercado:** ${betData.mercado}\n` + `📈 **Linha:** ${betData.linha_da_aposta}\n` + `💰 **Odd Tipster:** ${betData.odd_tipster}\n` + `💎 **Odd Real:** ${betData.odd_real}\n` + `📊 **Status:** ${betData.resultado_aposta}`);
            console.log('✅ Aposta salva com sucesso');
        } else {
            await sendTelegramMessage(chatId, `❌ **Erro ao salvar**\n\nHouve erro ao salvar no Google Sheets. Verifique os logs.`);
        }
    } else {
        // Odd inválida
        await sendTelegramMessage(chatId, `❌ **Odd inválida**\n\nPor favor, responda com um número válido ou 0 para \"não peguei\".\n\nExemplos: 1.85, 2.50, 0`);
        return; // Não remove do cache
    }
// REMOVER: Esta linha estava causando o erro
// pendingBets.delete(betKey);
}
async function sendTelegramMessage(chatId, text) {
    const botToken = process.env.TELEGRAM_BOT_TOKEN;
    try {
        console.log(`Enviando mensagem para chat ${chatId}:`, text);
        const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                chat_id: chatId,
                text: text,
                parse_mode: 'Markdown'
            })
        });
        const result = await response.json();
        if (!response.ok) {
            console.error('Erro na API do Telegram:', result);
        } else {
            console.log('Mensagem enviada com sucesso');
        }
        return result;
    } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
    }
}
async function getTelegramFileUrl(fileId) {
    const response = await fetch(`https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/getFile?file_id=${fileId}`);
    const data = await response.json();
    return `https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${data.result.file_path}`;
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__44775fda._.js.map